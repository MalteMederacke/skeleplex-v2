{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Skeleplex docs","text":"<p>This is a not-yet-working refactor of the Skeleplex pipeline. Please check back later!</p>"},{"location":"app/","title":"SkelePlex application","text":""},{"location":"app/#events","title":"Events","text":""},{"location":"app/#loading-data","title":"Loading data","text":"<p>This sequence is for loading data from the GUI. The events are connected in skeleplex.app.model.SkeleplexApp._connect_data_events()</p> <ol> <li>Load data button clicked: skeleplex.app.qt.app_controls.AppControlsWidget.load_data_widget.called()</li> <li>Event received by skeleplex.app.model.SkeleplexApp._load_data_clicked(). The new paths are set in the data manager (skeleplex.app.data.DataManager) and the data manager emits the DataManager.events.data() event.</li> <li>The data() event is received by the SkeleplexApp.load_main_viewer() and the data are loaded into the viewer.</li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>skeleplex<ul> <li>app<ul> <li>_app</li> <li>_constants</li> <li>_curate</li> <li>_data</li> <li>_utils</li> <li>_viewer_controller</li> <li>actions</li> <li>cellier<ul> <li>utils</li> </ul> </li> <li>functions</li> <li>qt<ul> <li>app_controls</li> <li>auxiliary_views</li> <li>flat_group_box</li> <li>main_viewer</li> <li>styles</li> <li>window</li> </ul> </li> </ul> </li> <li>data<ul> <li>bifurcating_tree</li> <li>skeleton_image</li> <li>skeletons</li> </ul> </li> <li>graph<ul> <li>constants</li> <li>image_to_graph</li> <li>modify_graph</li> <li>sample</li> <li>skeleton_graph</li> <li>spline</li> <li>utils</li> </ul> </li> <li>measurements<ul> <li>angles</li> <li>fit_surface</li> <li>graph_properties</li> <li>utils</li> </ul> </li> <li>skeleton<ul> <li>_segment</li> <li>_skeletonize</li> <li>_utils</li> </ul> </li> <li>utils<ul> <li>_geometry</li> </ul> </li> <li>visualize<ul> <li>spline</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/skeleplex/","title":"skeleplex","text":""},{"location":"reference/skeleplex/#skeleplex","title":"skeleplex","text":"<p>A Python package for analyzing skeletons.</p> <p>Modules:</p> <ul> <li> <code>app</code>           \u2013            <p>A desktop application for viewing and curating a skeleton.</p> </li> <li> <code>data</code>           \u2013            <p>Example data.</p> </li> <li> <code>graph</code>           \u2013            <p>Tools to create a graph of a skeleton.</p> </li> <li> <code>measurements</code>           \u2013            <p>Tools to compute properties of a skeleton.</p> </li> <li> <code>skeleton</code>           \u2013            <p>Tools to create a skeleton image of a structure.</p> </li> <li> <code>utils</code>           \u2013            <p>Utilities for operating on the skeleton.</p> </li> <li> <code>visualize</code>           \u2013            <p>Module for interactive visualization and curation of the skeleton.</p> </li> </ul>"},{"location":"reference/skeleplex/app/","title":"app","text":""},{"location":"reference/skeleplex/app/#skeleplex.app","title":"skeleplex.app","text":"<p>A desktop application for viewing and curating a skeleton.</p> <p>Modules:</p> <ul> <li> <code>actions</code>           \u2013            <p>Actions to be registered for the application.</p> </li> <li> <code>cellier</code>           \u2013            <p>Cellier rendering module.</p> </li> <li> <code>functions</code>           \u2013            <p>Functions for the app.</p> </li> <li> <code>qt</code>           \u2013            <p>Qt widgets for the SkelePlex app.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DataManager</code>           \u2013            <p>A class to manage data.</p> </li> <li> <code>SkelePlexApp</code>           \u2013            <p>The main application class.</p> </li> <li> <code>SkeletonDataPaths</code>           \u2013            <p>A class storing the state of the skeleton dataset.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>run</code>             \u2013              <p>Start the Qt application event loop.</p> </li> <li> <code>view_skeleton</code>             \u2013              <p>Launch the skeleton viewer application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager","title":"DataManager","text":"<pre><code>DataManager(file_paths: SkeletonDataPaths, selection: SelectionManager | None = None, load_data: bool = True)\n</code></pre> <p>A class to manage data.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>events</code>               (<code>DataEvents</code>)           \u2013            <p>The events for the DataManager class.</p> </li> <li> <code>node_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>The coordinates of the nodes in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>node_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>The keys for the nodes in the skeleton graph. This is index-matched with the node_coordinates array. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>The coordinates for rendering the edges in the skeleton graph as line segments. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_indices</code>               (<code>ndarray | None</code>)           \u2013            <p>The indices for the edges in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>The keys for edges of each edge coordinate in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              <p>Load data.</p> </li> <li> <code>to_dict</code>             \u2013              <p>Convert to json-serializable dictionary.</p> </li> </ul> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def __init__(\n    self,\n    file_paths: SkeletonDataPaths,\n    selection: SelectionManager | None = None,\n    load_data: bool = True,\n) -&gt; None:\n    self._file_paths = file_paths\n\n    self._view = DataView(\n        data_manager=self, mode=ViewMode.ALL, bounding_box=BoundingBoxData()\n    )\n\n    # make the selection model\n    if selection is None:\n        selection = SelectionManager(\n            edge=EdgeSelectionManager(enabled=False, values=set()),\n            node=NodeSelectionManager(enabled=False, values=set()),\n        )\n    self._selection = selection\n\n    # initialize the data\n    self._skeleton_graph: SkeletonGraph | None = None\n    self._node_coordinates: np.ndarray | None = None\n    self._edge_coordinates: np.ndarray | None = None\n    self._edge_indices: np.ndarray | None = None\n    self._edge_keys: np.ndarray | None = None\n\n    if self.file_paths.has_paths() and load_data:\n        self.load()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager(file_paths)","title":"<code>file_paths</code>","text":"(<code>SkeletonDataPaths</code>)           \u2013            <p>The paths to the data files.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager(selection)","title":"<code>selection</code>","text":"(<code>SelectionManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The selection manager.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.edge_coordinates","title":"edge_coordinates  <code>property</code>","text":"<pre><code>edge_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the edges in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge, 3) array of edge coordinates.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.edge_indices","title":"edge_indices  <code>property</code>","text":"<pre><code>edge_indices: ndarray | None\n</code></pre> <p>Get the indices of the edges in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge indices.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.edge_keys","title":"edge_keys  <code>property</code>","text":"<pre><code>edge_keys: ndarray | None\n</code></pre> <p>Get the keys of the edge for each edge coordinate in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge keys.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.file_paths","title":"file_paths  <code>property</code>","text":"<pre><code>file_paths: SkeletonDataPaths\n</code></pre> <p>Get the file paths.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the nodes in the skeleton graph.</p> <p>(n_nodes, 3) array of node coordinates.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.node_keys","title":"node_keys  <code>property</code>","text":"<pre><code>node_keys: ndarray | None\n</code></pre> <p>Get the keys of the nodes in the skeleton graph.</p> <p>(n_nodes,) array of node keys. These are index-matched with the node_coordinates array.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.selection","title":"selection  <code>property</code>","text":"<pre><code>selection: SelectionManager\n</code></pre> <p>Get the current data selection.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.skeleton_graph","title":"skeleton_graph  <code>property</code>","text":"<pre><code>skeleton_graph: SkeletonGraph\n</code></pre> <p>Get the skeleton graph.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.view","title":"view  <code>property</code>","text":"<pre><code>view: DataView\n</code></pre> <p>Get the current data view.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.load","title":"load","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load data.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Load data.\"\"\"\n    # load the skeleton graph\n    if self.file_paths.skeleton_graph:\n        log.info(f\"Loading skeleton graph from {self.file_paths.skeleton_graph}\")\n        self._skeleton_graph = SkeletonGraph.from_json_file(\n            self.file_paths.skeleton_graph\n        )\n        self._update_node_coordinates()\n        self._update_edge_coordinates()\n    else:\n        log.info(\"No skeleton graph loaded.\")\n        self._skeleton_graph = None\n\n    self.events.data.emit()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert to json-serializable dictionary.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert to json-serializable dictionary.\"\"\"\n    return self._data.to_dict()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp","title":"SkelePlexApp","text":"<pre><code>SkelePlexApp(data: DataManager | None = None, selection: SelectionManager | None = None)\n</code></pre> <p>               Bases: <code>Application</code></p> <p>The main application class.</p> <p>Methods:</p> <ul> <li> <code>add_auxiliary_widget</code>             \u2013              <p>Add a widget to the right dock of the main window.</p> </li> <li> <code>load_main_viewer</code>             \u2013              <p>Add the data to the main viewer.</p> </li> <li> <code>look_at_skeleton</code>             \u2013              <p>Set the camera in the main viewer to look at the skeleton.</p> </li> <li> <code>show</code>             \u2013              <p>Show the app.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>curate</code>               (<code>CurationManager</code>)           \u2013            <p>Get the curation manager.</p> </li> <li> <code>data</code>               (<code>DataManager</code>)           \u2013            <p>Get the data manager.</p> </li> </ul> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def __init__(\n    self, data: DataManager | None = None, selection: SelectionManager | None = None\n) -&gt; None:\n    super().__init__(\"SkelePlex\")\n\n    # make the data model\n    if data is None:\n        data = DataManager(file_paths=SkeletonDataPaths(), selection=selection)\n    self._data = data\n\n    # add the curation manager\n    self._curate = CurationManager(\n        data_manager=self._data,\n    )\n\n    # make the viewer model\n    self._viewer = ViewerController(parent_widget=None)\n    # self._viewer = ViewerController(parent_widget=self._main_window)\n\n    # ACTIONS is a list of Action objects.\n    for action in ACTIONS:\n        self.register_action(action)\n    self._register_data_actions()\n\n    self._main_window = MainWindow(\n        app=self,\n    )\n    # This will build a menu bar based on these menus\n    self._main_window.setModelMenuBar([MenuId.FILE, MenuId.EDIT, MenuId.DATA])\n\n    for canvas in self._viewer._backend._canvas_widgets.values():\n        # add the canvas widgets\n        self._main_window._set_main_viewer_widget(canvas)\n\n    # connect the data events\n    self._connect_data_events()\n\n    # connect the selection events\n    self._connect_selection_events()\n\n    # update the data view\n    self.data.view.update()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.curate","title":"curate  <code>property</code>","text":"<pre><code>curate: CurationManager\n</code></pre> <p>Get the curation manager.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.data","title":"data  <code>property</code>","text":"<pre><code>data: DataManager\n</code></pre> <p>Get the data manager.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.add_auxiliary_widget","title":"add_auxiliary_widget","text":"<pre><code>add_auxiliary_widget(widget, name: str) -&gt; None\n</code></pre> <p>Add a widget to the right dock of the main window.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def add_auxiliary_widget(self, widget, name: str) -&gt; None:\n    \"\"\"Add a widget to the right dock of the main window.\"\"\"\n    self._main_window.add_auxiliary_widget(widget, name)\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.load_main_viewer","title":"load_main_viewer","text":"<pre><code>load_main_viewer() -&gt; None\n</code></pre> <p>Add the data to the main viewer.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def load_main_viewer(self) -&gt; None:\n    \"\"\"Add the data to the main viewer.\"\"\"\n    log.debug(\"Loading data into the main viewer...\")\n    if self.data.skeleton_graph is None:\n        log.debug(\"No skeleton graph loaded.\")\n        return\n\n    self._viewer.main_canvas.update_skeleton_geometry(\n        node_coordinates=self.data.view.node_coordinates,\n        edge_coordinates=self.data.view.edge_coordinates,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.look_at_skeleton","title":"look_at_skeleton","text":"<pre><code>look_at_skeleton() -&gt; None\n</code></pre> <p>Set the camera in the main viewer to look at the skeleton.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def look_at_skeleton(self) -&gt; None:\n    \"\"\"Set the camera in the main viewer to look at the skeleton.\"\"\"\n    self._viewer.main_canvas.look_at_skeleton()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show the app.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the app.\"\"\"\n    self._main_window.show()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths","title":"SkeletonDataPaths","text":"<p>               Bases: <code>EventedModel</code></p> <p>A class storing the state of the skeleton dataset.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>has_paths</code>             \u2013              <p>Returns true if any of the paths are set.</p> </li> </ul>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths(image)","title":"<code>image</code>","text":"(<code>FilePath | None</code>)           \u2013            <p>The path to the image file.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths(segmentation)","title":"<code>segmentation</code>","text":"(<code>FilePath | None</code>)           \u2013            <p>The path to the segmentation image file.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>FilePath</code>)           \u2013            <p>The path to the skeleton graph file.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths.has_paths","title":"has_paths","text":"<pre><code>has_paths() -&gt; bool\n</code></pre> <p>Returns true if any of the paths are set.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def has_paths(self) -&gt; bool:\n    \"\"\"Returns true if any of the paths are set.\"\"\"\n    return any([self.image, self.segmentation, self.skeleton_graph])\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Start the Qt application event loop.</p> <p>This is meant to be used in a script. This should be called after the viewer is set up.</p> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def run():\n    \"\"\"Start the Qt application event loop.\n\n    This is meant to be used in a script.\n    This should be called after the viewer is set up.\n    \"\"\"\n    # get the qapplication instance\n    qapp = QApplication.instance() or QApplication([])\n\n    # start the Qt application event loop\n    qapp.exec_()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.view_skeleton","title":"view_skeleton","text":"<pre><code>view_skeleton(graph_path: str)\n</code></pre> <p>Launch the skeleton viewer application.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SkelePlexApp</code>           \u2013            <p>The SkelePlex application instance for viewing the skeleton.</p> </li> </ul> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def view_skeleton(\n    graph_path: str,\n):\n    \"\"\"Launch the skeleton viewer application.\n\n    Parameters\n    ----------\n    graph_path : str\n        Path to the skeleton graph JSON file.\n\n    Returns\n    -------\n    SkelePlexApp\n        The SkelePlex application instance for viewing the skeleton.\n    \"\"\"\n    global _app_ref\n\n    # get the qapplication instance\n    qapp = QApplication.instance() or QApplication([])\n\n    # Store reference to prevent garbage collection\n    _app_ref = qapp\n\n    # load the data\n    data_manager = DataManager(file_paths=SkeletonDataPaths(skeleton_graph=graph_path))\n\n    # make the viewer\n    viewer = SkelePlexApp(data=data_manager)\n    viewer.show()\n\n    # Wait a short time for things to load and then look at the skeleton\n    # this is a hack...do something smarter later\n    timer = QTimer()\n    timer.singleShot(100, viewer.look_at_skeleton)\n\n    # start the Qt event loop if in Jupyter/IPython\n    if should_launch_ipython_event_loop():\n        start_qt_loop_ipython()\n\n    return viewer\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.view_skeleton(graph_path)","title":"<code>graph_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the skeleton graph JSON file.</p>"},{"location":"reference/skeleplex/app/_app/","title":"_app","text":""},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app","title":"skeleplex.app._app","text":"<p>The main application model.</p> <p>Classes:</p> <ul> <li> <code>SkelePlexApp</code>           \u2013            <p>The main application class.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp","title":"SkelePlexApp","text":"<pre><code>SkelePlexApp(data: DataManager | None = None, selection: SelectionManager | None = None)\n</code></pre> <p>               Bases: <code>Application</code></p> <p>The main application class.</p> <p>Methods:</p> <ul> <li> <code>add_auxiliary_widget</code>             \u2013              <p>Add a widget to the right dock of the main window.</p> </li> <li> <code>load_main_viewer</code>             \u2013              <p>Add the data to the main viewer.</p> </li> <li> <code>look_at_skeleton</code>             \u2013              <p>Set the camera in the main viewer to look at the skeleton.</p> </li> <li> <code>show</code>             \u2013              <p>Show the app.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>curate</code>               (<code>CurationManager</code>)           \u2013            <p>Get the curation manager.</p> </li> <li> <code>data</code>               (<code>DataManager</code>)           \u2013            <p>Get the data manager.</p> </li> </ul> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def __init__(\n    self, data: DataManager | None = None, selection: SelectionManager | None = None\n) -&gt; None:\n    super().__init__(\"SkelePlex\")\n\n    # make the data model\n    if data is None:\n        data = DataManager(file_paths=SkeletonDataPaths(), selection=selection)\n    self._data = data\n\n    # add the curation manager\n    self._curate = CurationManager(\n        data_manager=self._data,\n    )\n\n    # make the viewer model\n    self._viewer = ViewerController(parent_widget=None)\n    # self._viewer = ViewerController(parent_widget=self._main_window)\n\n    # ACTIONS is a list of Action objects.\n    for action in ACTIONS:\n        self.register_action(action)\n    self._register_data_actions()\n\n    self._main_window = MainWindow(\n        app=self,\n    )\n    # This will build a menu bar based on these menus\n    self._main_window.setModelMenuBar([MenuId.FILE, MenuId.EDIT, MenuId.DATA])\n\n    for canvas in self._viewer._backend._canvas_widgets.values():\n        # add the canvas widgets\n        self._main_window._set_main_viewer_widget(canvas)\n\n    # connect the data events\n    self._connect_data_events()\n\n    # connect the selection events\n    self._connect_selection_events()\n\n    # update the data view\n    self.data.view.update()\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.curate","title":"curate  <code>property</code>","text":"<pre><code>curate: CurationManager\n</code></pre> <p>Get the curation manager.</p>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.data","title":"data  <code>property</code>","text":"<pre><code>data: DataManager\n</code></pre> <p>Get the data manager.</p>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.add_auxiliary_widget","title":"add_auxiliary_widget","text":"<pre><code>add_auxiliary_widget(widget, name: str) -&gt; None\n</code></pre> <p>Add a widget to the right dock of the main window.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def add_auxiliary_widget(self, widget, name: str) -&gt; None:\n    \"\"\"Add a widget to the right dock of the main window.\"\"\"\n    self._main_window.add_auxiliary_widget(widget, name)\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.load_main_viewer","title":"load_main_viewer","text":"<pre><code>load_main_viewer() -&gt; None\n</code></pre> <p>Add the data to the main viewer.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def load_main_viewer(self) -&gt; None:\n    \"\"\"Add the data to the main viewer.\"\"\"\n    log.debug(\"Loading data into the main viewer...\")\n    if self.data.skeleton_graph is None:\n        log.debug(\"No skeleton graph loaded.\")\n        return\n\n    self._viewer.main_canvas.update_skeleton_geometry(\n        node_coordinates=self.data.view.node_coordinates,\n        edge_coordinates=self.data.view.edge_coordinates,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.look_at_skeleton","title":"look_at_skeleton","text":"<pre><code>look_at_skeleton() -&gt; None\n</code></pre> <p>Set the camera in the main viewer to look at the skeleton.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def look_at_skeleton(self) -&gt; None:\n    \"\"\"Set the camera in the main viewer to look at the skeleton.\"\"\"\n    self._viewer.main_canvas.look_at_skeleton()\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show the app.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the app.\"\"\"\n    self._main_window.show()\n</code></pre>"},{"location":"reference/skeleplex/app/_constants/","title":"_constants","text":""},{"location":"reference/skeleplex/app/_constants/#skeleplex.app._constants","title":"skeleplex.app._constants","text":"<p>Constants for the application.</p> <p>Classes:</p> <ul> <li> <code>CommandId</code>           \u2013            <p>Command identifiers for the application.</p> </li> <li> <code>MenuId</code>           \u2013            <p>Menu identifiers for the application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_constants/#skeleplex.app._constants.CommandId","title":"CommandId","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Command identifiers for the application.</p>"},{"location":"reference/skeleplex/app/_constants/#skeleplex.app._constants.MenuId","title":"MenuId","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Menu identifiers for the application.</p>"},{"location":"reference/skeleplex/app/_curate/","title":"_curate","text":""},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate","title":"skeleplex.app._curate","text":"<p>Classes:</p> <ul> <li> <code>CurationManager</code>           \u2013            </li> <li> <code>LIFOBuffer</code>           \u2013            <p>A last-in-first-out buffer with a maximum size.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>edge_string_to_key</code>             \u2013              <p>Parse a string representation of a set of tuples back into a Python set.</p> </li> <li> <code>node_string_to_node_keys</code>             \u2013              <p>Parse a string representation of a set of integers back into a Python set.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager","title":"CurationManager","text":"<pre><code>CurationManager(data_manager: DataManager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>delete_edge</code>             \u2013              <p>Delete an edge from the skeleton graph.</p> </li> <li> <code>redo</code>             \u2013              <p>Redo the last undone action on the skeleton graph.</p> </li> <li> <code>undo</code>             \u2013              <p>Undo the last action performed on the skeleton graph.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def __init__(\n    self,\n    data_manager: \"DataManager\",\n):\n    self._data = data_manager\n\n    # buffers for undo and redo operations\n    self._undo_buffer = LIFOBuffer(max_size=10)\n    self._redo_buffer = LIFOBuffer(max_size=10)\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.delete_edge","title":"delete_edge","text":"<pre><code>delete_edge(edge: set[tuple[int, int]] | str, redraw: bool = True) -&gt; None\n</code></pre> <p>Delete an edge from the skeleton graph.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def delete_edge(\n    self,\n    edge: Annotated[set[tuple[int, int]] | str, {\"widget_type\": \"LineEdit\"}],\n    redraw: bool = True,\n) -&gt; None:\n    \"\"\"Delete an edge from the skeleton graph.\n\n    Parameters\n    ----------\n    edge : tuple[int, int] | None\n        The edge to delete, represented as a tuple of node IDs.\n        If None, no action is taken.\n    redraw : bool\n        Flag set to True to redraw the graph after deletion.\n        Defaults value is True.\n    \"\"\"\n    if len(edge) == 0:\n        # if no edge is selected, do nothing\n        return\n\n    # parse the edge if it is a string\n    edges = edge_string_to_key(edge) if isinstance(edge, str) else edge\n\n    # store the previous state in the undo buffer\n    self._undo_buffer.push(deepcopy(self._data.skeleton_graph))\n\n    # delete the edge from the skeleton graph\n    for edge in edges:\n        delete_edge(skeleton_graph=self._data.skeleton_graph, edge=edge)\n\n    if redraw:\n        # redraw the graph\n        self._update_and_request_redraw()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.delete_edge(edge)","title":"<code>edge</code>","text":"(<code>tuple[int, int] | None</code>)           \u2013            <p>The edge to delete, represented as a tuple of node IDs. If None, no action is taken.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.delete_edge(redraw)","title":"<code>redraw</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag set to True to redraw the graph after deletion. Defaults value is True.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.redo","title":"redo","text":"<pre><code>redo(redraw: bool = True) -&gt; None\n</code></pre> <p>Redo the last undone action on the skeleton graph.</p> <p>This method restores the skeleton graph to the next state in the undo buffer. If there are no actions to redo, it does nothing.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def redo(self, redraw: bool = True) -&gt; None:\n    \"\"\"Redo the last undone action on the skeleton graph.\n\n    This method restores the skeleton graph to the next state in the undo buffer.\n    If there are no actions to redo, it does nothing.\n\n    Parameters\n    ----------\n    redraw : bool\n        Flag set to True to redraw the graph after redoing.\n        Defaults value is True.\n    \"\"\"\n    if len(self._redo_buffer) == 0:\n        # if there are no actions to redo, do nothing\n        return\n\n    # store the current state in the undo buffer\n    self._undo_buffer.push(deepcopy(self._data.skeleton_graph))\n\n    # restore the next state from the redo buffer\n    next_state = self._redo_buffer.pop()\n    self._data._skeleton_graph = next_state\n\n    if redraw:\n        # redraw the graph\n        self._update_and_request_redraw()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.redo(redraw)","title":"<code>redraw</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag set to True to redraw the graph after redoing. Defaults value is True.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.undo","title":"undo","text":"<pre><code>undo(redraw: bool = True) -&gt; None\n</code></pre> <p>Undo the last action performed on the skeleton graph.</p> <p>This method restores the skeleton graph to its previous state using the undo buffer. If there are no actions to undo, it does nothing.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def undo(self, redraw: bool = True) -&gt; None:\n    \"\"\"Undo the last action performed on the skeleton graph.\n\n    This method restores the skeleton graph to its previous state\n    using the undo buffer. If there are no actions to undo, it does nothing.\n\n    Parameters\n    ----------\n    redraw : bool\n        Flag set to True to redraw the graph after undoing.\n        Defaults value is True.\n    \"\"\"\n    if len(self._undo_buffer) == 0:\n        # if there are no actions to undo, do nothing\n        return\n\n    # store the current state in the redo buffer\n    self._redo_buffer.push(deepcopy(self._data.skeleton_graph))\n\n    # restore the previous state from the undo buffer\n    previous_state = self._undo_buffer.pop()\n    self._data._skeleton_graph = previous_state\n\n    if redraw:\n        # redraw the graph\n        self._update_and_request_redraw()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.undo(redraw)","title":"<code>redraw</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag set to True to redraw the graph after undoing. Defaults value is True.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer","title":"LIFOBuffer","text":"<pre><code>LIFOBuffer(max_size: int)\n</code></pre> <p>A last-in-first-out buffer with a maximum size.</p> <p>This buffer automatically removes the oldest items when the maximum size is exceeded, maintaining LIFO ordering for retrieval.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If max_size is not a positive integer.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>clear</code>             \u2013              <p>Remove all items from the buffer.</p> </li> <li> <code>pop</code>             \u2013              <p>Remove and return the most recently added item.</p> </li> <li> <code>push</code>             \u2013              <p>Add an item to the buffer.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>max_size</code>               (<code>int</code>)           \u2013            <p>Get the maximum capacity of the buffer.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def __init__(self, max_size: int) -&gt; None:\n    if max_size &lt;= 0:\n        raise ValueError(\"max_size must be greater than 0\")\n\n    self._buffer = deque(maxlen=max_size)\n    self._max_size = max_size\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer(max_size)","title":"<code>max_size</code>","text":"(<code>int</code>)           \u2013            <p>The maximum number of items the buffer can hold. Must be greater than 0.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size: int\n</code></pre> <p>Get the maximum capacity of the buffer.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The maximum number of items the buffer can hold.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all items from the buffer.</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all items from the buffer.\"\"\"\n    self._buffer.clear()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.pop","title":"pop","text":"<pre><code>pop() -&gt; Any\n</code></pre> <p>Remove and return the most recently added item.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The most recently added item.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>IndexError</code>             \u2013            <p>If the buffer is empty.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def pop(self) -&gt; Any:\n    \"\"\"Remove and return the most recently added item.\n\n    Returns\n    -------\n    Any\n        The most recently added item.\n\n    Raises\n    ------\n    IndexError\n        If the buffer is empty.\n    \"\"\"\n    if not self._buffer:\n        raise IndexError(\"pop from empty buffer\")\n    return self._buffer.pop()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.push","title":"push","text":"<pre><code>push(item: Any) -&gt; None\n</code></pre> <p>Add an item to the buffer.</p> <p>If the buffer is at maximum capacity, the oldest item will be automatically removed.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def push(self, item: Any) -&gt; None:\n    \"\"\"Add an item to the buffer.\n\n    If the buffer is at maximum capacity, the oldest item\n    will be automatically removed.\n\n    Parameters\n    ----------\n    item : Any\n        The item to add to the buffer.\n    \"\"\"\n    self._buffer.append(item)\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.push(item)","title":"<code>item</code>","text":"(<code>Any</code>)           \u2013            <p>The item to add to the buffer.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.edge_string_to_key","title":"edge_string_to_key","text":"<pre><code>edge_string_to_key(edge_string: str) -&gt; set[tuple[int, ...]]\n</code></pre> <p>Parse a string representation of a set of tuples back into a Python set.</p> <p>This function safely converts string representations of sets containing tuples back into their original Python data structure. It handles the case where the string was created using str() on a set of tuples.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>set[tuple[int, ...]]</code>           \u2013            <p>A set containing tuples parsed from the input string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string cannot be safely parsed as a set of tuples.</p> </li> <li> <code>SyntaxError</code>             \u2013            <p>If the string contains invalid Python syntax.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def edge_string_to_key(edge_string: str) -&gt; set[tuple[int, ...]]:\n    \"\"\"Parse a string representation of a set of tuples back into a Python set.\n\n    This function safely converts string representations of sets containing tuples\n    back into their original Python data structure. It handles the case where\n    the string was created using str() on a set of tuples.\n\n    Parameters\n    ----------\n    edge_string : str\n        String representation of a set of tuples, typically created by\n        calling str() on a set object containing tuples.\n\n    Returns\n    -------\n    set[tuple[int, ...]]\n        A set containing tuples parsed from the input string.\n\n    Raises\n    ------\n    ValueError\n        If the string cannot be safely parsed as a set of tuples.\n    SyntaxError\n        If the string contains invalid Python syntax.\n    \"\"\"\n    try:\n        # parse the string to convert it back to a set of tuples\n        parsed_result = ast.literal_eval(edge_string)\n\n        # Verify that the result is a set\n        if not isinstance(parsed_result, set):\n            raise ValueError(f\"Expected a set, but got {type(parsed_result).__name__}\")\n\n        # Verify that all elements are tuples\n        for element in parsed_result:\n            if not isinstance(element, tuple):\n                raise ValueError(\"Expected all elements must be tuples\")\n\n        return parsed_result\n\n    except (ValueError, SyntaxError) as e:\n        raise ValueError(f\"Could not parse edge string '{edge_string}': {e}\") from e\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.edge_string_to_key(edge_string)","title":"<code>edge_string</code>","text":"(<code>str</code>)           \u2013            <p>String representation of a set of tuples, typically created by calling str() on a set object containing tuples.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.node_string_to_node_keys","title":"node_string_to_node_keys","text":"<pre><code>node_string_to_node_keys(node_string: str) -&gt; set[int]\n</code></pre> <p>Parse a string representation of a set of integers back into a Python set.</p> <p>This function safely converts string representations of sets containing integers back into their original Python data structure. It handles the case where the string was created using str() on a set of integers.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>set[int]</code>           \u2013            <p>A set containing integers parsed from the input string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string cannot be safely parsed as a set of integers, or if the string exceeds the maximum allowed length.</p> </li> <li> <code>SyntaxError</code>             \u2013            <p>If the string contains invalid Python syntax.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def node_string_to_node_keys(node_string: str) -&gt; set[int]:\n    \"\"\"Parse a string representation of a set of integers back into a Python set.\n\n    This function safely converts string representations of sets containing integers\n    back into their original Python data structure. It handles the case where\n    the string was created using str() on a set of integers.\n\n    Parameters\n    ----------\n    node_string : str\n        String representation of a set of integers, typically created by\n        calling str() on a set object containing integers.\n\n    Returns\n    -------\n    set[int]\n        A set containing integers parsed from the input string.\n\n    Raises\n    ------\n    ValueError\n        If the string cannot be safely parsed as a set of integers,\n        or if the string exceeds the maximum allowed length.\n    SyntaxError\n        If the string contains invalid Python syntax.\n    \"\"\"\n    try:\n        parsed_result = ast.literal_eval(node_string)\n\n        # Verify that the result is a set\n        if not isinstance(parsed_result, set):\n            raise ValueError(f\"Expected a set, but got {type(parsed_result).__name__}\")\n\n        # Verify that all elements are integers\n        for element in parsed_result:\n            if not isinstance(element, int):\n                raise ValueError(\"All elements must be integers\")\n\n        return parsed_result\n\n    except (ValueError, SyntaxError) as e:\n        raise ValueError(f\"Could not parse node string '{node_string}': {e}\") from e\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.node_string_to_node_keys(node_string)","title":"<code>node_string</code>","text":"(<code>str</code>)           \u2013            <p>String representation of a set of integers, typically created by calling str() on a set object containing integers.</p>"},{"location":"reference/skeleplex/app/_data/","title":"_data","text":""},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data","title":"skeleplex.app._data","text":"<p>Module for handling data in the SkelePlex application.</p> <p>Classes:</p> <ul> <li> <code>AllViewRequest</code>           \u2013            <p>Request to view all data in the skeleton graph.</p> </li> <li> <code>BoundingBoxData</code>           \u2013            <p>The current bounding box parameters.</p> </li> <li> <code>BoundingBoxEvents</code>           \u2013            <p>Events for the DataManager class.</p> </li> <li> <code>BoundingBoxViewRequest</code>           \u2013            <p>Request to view an axis-aligned bounding box region.</p> </li> <li> <code>DataEvents</code>           \u2013            <p>Events for the DataManager class.</p> </li> <li> <code>DataManager</code>           \u2013            <p>A class to manage data.</p> </li> <li> <code>DataView</code>           \u2013            <p>A class to manage the current view on the data.</p> </li> <li> <code>EdgeSelectionManager</code>           \u2013            <p>Class to manage selection of edge in the viewer.</p> </li> <li> <code>EdgeSelectionPasteRequest</code>           \u2013            <p>Selected edges to paste.</p> </li> <li> <code>NodeSelectionManager</code>           \u2013            <p>Class to manage selection of nodes in the viewer.</p> </li> <li> <code>NodeSelectionPasteRequest</code>           \u2013            <p>Selected nodes to paste.</p> </li> <li> <code>SelectionManager</code>           \u2013            <p>Class to manage selection of data in the viewer.</p> </li> <li> <code>SkeletonDataPaths</code>           \u2013            <p>A class storing the state of the skeleton dataset.</p> </li> <li> <code>ViewEvents</code>           \u2013            <p>Events for the DataManager class.</p> </li> <li> <code>ViewMode</code>           \u2013            <p>The different viewing modes.</p> </li> <li> <code>ViewRequest</code>           \u2013            <p>Base Request to view data in the skeleton graph.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.AllViewRequest","title":"AllViewRequest  <code>dataclass</code>","text":"<pre><code>AllViewRequest()\n</code></pre> <p>               Bases: <code>ViewRequest</code></p> <p>Request to view all data in the skeleton graph.</p> <p>This is used for passing requests to view all data in the skeleton graph. It does not require any parameters.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxData","title":"BoundingBoxData","text":"<pre><code>BoundingBoxData(min_coordinate: ndarray | None = None, max_coordinate: ndarray | None = None)\n</code></pre> <p>The current bounding box parameters.</p> <p>Attributes:</p> <ul> <li> <code>is_populated</code>               (<code>bool</code>)           \u2013            <p>Returns True if the min and max coordinate have been set.</p> </li> <li> <code>max_coordinate</code>               (<code>ndarray | None</code>)           \u2013            <p>Returns the minimum corner of the bounding box.</p> </li> <li> <code>min_coordinate</code>               (<code>ndarray | None</code>)           \u2013            <p>Returns the minimum corner of the bounding box.</p> </li> </ul> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def __init__(\n    self,\n    min_coordinate: np.ndarray | None = None,\n    max_coordinate: np.ndarray | None = None,\n):\n    self._min_coordinate = min_coordinate\n    self._max_coordinate = max_coordinate\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxData.is_populated","title":"is_populated  <code>property</code>","text":"<pre><code>is_populated: bool\n</code></pre> <p>Returns True if the min and max coordinate have been set.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxData.max_coordinate","title":"max_coordinate  <code>property</code> <code>writable</code>","text":"<pre><code>max_coordinate: ndarray | None\n</code></pre> <p>Returns the minimum corner of the bounding box.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxData.min_coordinate","title":"min_coordinate  <code>property</code> <code>writable</code>","text":"<pre><code>min_coordinate: ndarray | None\n</code></pre> <p>Returns the minimum corner of the bounding box.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxEvents","title":"BoundingBoxEvents","text":"<p>               Bases: <code>SignalGroup</code></p> <p>Events for the DataManager class.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxViewRequest","title":"BoundingBoxViewRequest  <code>dataclass</code>","text":"<pre><code>BoundingBoxViewRequest(minimum: ndarray, maximum: ndarray)\n</code></pre> <p>               Bases: <code>ViewRequest</code></p> <p>Request to view an axis-aligned bounding box region.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxViewRequest(minimum)","title":"<code>minimum</code>","text":"(<code>ndarray</code>)           \u2013            <p>The minimum corner of the axis-aligned bounding box.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxViewRequest(maximum)","title":"<code>maximum</code>","text":"(<code>ndarray</code>)           \u2013            <p>The maximum corner of the axis-aligned bounding box.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataEvents","title":"DataEvents","text":"<p>               Bases: <code>SignalGroup</code></p> <p>Events for the DataManager class.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager","title":"DataManager","text":"<pre><code>DataManager(file_paths: SkeletonDataPaths, selection: SelectionManager | None = None, load_data: bool = True)\n</code></pre> <p>A class to manage data.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>events</code>               (<code>DataEvents</code>)           \u2013            <p>The events for the DataManager class.</p> </li> <li> <code>node_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>The coordinates of the nodes in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>node_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>The keys for the nodes in the skeleton graph. This is index-matched with the node_coordinates array. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>The coordinates for rendering the edges in the skeleton graph as line segments. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_indices</code>               (<code>ndarray | None</code>)           \u2013            <p>The indices for the edges in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>The keys for edges of each edge coordinate in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              <p>Load data.</p> </li> <li> <code>to_dict</code>             \u2013              <p>Convert to json-serializable dictionary.</p> </li> </ul> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def __init__(\n    self,\n    file_paths: SkeletonDataPaths,\n    selection: SelectionManager | None = None,\n    load_data: bool = True,\n) -&gt; None:\n    self._file_paths = file_paths\n\n    self._view = DataView(\n        data_manager=self, mode=ViewMode.ALL, bounding_box=BoundingBoxData()\n    )\n\n    # make the selection model\n    if selection is None:\n        selection = SelectionManager(\n            edge=EdgeSelectionManager(enabled=False, values=set()),\n            node=NodeSelectionManager(enabled=False, values=set()),\n        )\n    self._selection = selection\n\n    # initialize the data\n    self._skeleton_graph: SkeletonGraph | None = None\n    self._node_coordinates: np.ndarray | None = None\n    self._edge_coordinates: np.ndarray | None = None\n    self._edge_indices: np.ndarray | None = None\n    self._edge_keys: np.ndarray | None = None\n\n    if self.file_paths.has_paths() and load_data:\n        self.load()\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager(file_paths)","title":"<code>file_paths</code>","text":"(<code>SkeletonDataPaths</code>)           \u2013            <p>The paths to the data files.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager(selection)","title":"<code>selection</code>","text":"(<code>SelectionManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The selection manager.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.edge_coordinates","title":"edge_coordinates  <code>property</code>","text":"<pre><code>edge_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the edges in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge, 3) array of edge coordinates.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.edge_indices","title":"edge_indices  <code>property</code>","text":"<pre><code>edge_indices: ndarray | None\n</code></pre> <p>Get the indices of the edges in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge indices.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.edge_keys","title":"edge_keys  <code>property</code>","text":"<pre><code>edge_keys: ndarray | None\n</code></pre> <p>Get the keys of the edge for each edge coordinate in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge keys.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.file_paths","title":"file_paths  <code>property</code>","text":"<pre><code>file_paths: SkeletonDataPaths\n</code></pre> <p>Get the file paths.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the nodes in the skeleton graph.</p> <p>(n_nodes, 3) array of node coordinates.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.node_keys","title":"node_keys  <code>property</code>","text":"<pre><code>node_keys: ndarray | None\n</code></pre> <p>Get the keys of the nodes in the skeleton graph.</p> <p>(n_nodes,) array of node keys. These are index-matched with the node_coordinates array.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.selection","title":"selection  <code>property</code>","text":"<pre><code>selection: SelectionManager\n</code></pre> <p>Get the current data selection.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.skeleton_graph","title":"skeleton_graph  <code>property</code>","text":"<pre><code>skeleton_graph: SkeletonGraph\n</code></pre> <p>Get the skeleton graph.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.view","title":"view  <code>property</code>","text":"<pre><code>view: DataView\n</code></pre> <p>Get the current data view.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.load","title":"load","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load data.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Load data.\"\"\"\n    # load the skeleton graph\n    if self.file_paths.skeleton_graph:\n        log.info(f\"Loading skeleton graph from {self.file_paths.skeleton_graph}\")\n        self._skeleton_graph = SkeletonGraph.from_json_file(\n            self.file_paths.skeleton_graph\n        )\n        self._update_node_coordinates()\n        self._update_edge_coordinates()\n    else:\n        log.info(\"No skeleton graph loaded.\")\n        self._skeleton_graph = None\n\n    self.events.data.emit()\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert to json-serializable dictionary.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert to json-serializable dictionary.\"\"\"\n    return self._data.to_dict()\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView","title":"DataView","text":"<pre><code>DataView(data_manager: DataManager, bounding_box: BoundingBoxData, mode: ViewMode = ALL)\n</code></pre> <p>A class to manage the current view on the data.</p> <p>Methods:</p> <ul> <li> <code>update</code>             \u2013              <p>Update the data for the currently specified view.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>bounding_box</code>               (<code>BoundingBoxData</code>)           \u2013            <p>Get the current bounding box data.</p> </li> <li> <code>edge_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the coordinates of the current view of the edges in the rendered graph.</p> </li> <li> <code>edge_indices</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the indices of the current view of the edges in the rendered graph.</p> </li> <li> <code>edge_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the keys of the edge for each edge coordinate in the rendered graph.</p> </li> <li> <code>highlighted_edge_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>Get keys of the highlighted edges for each coordinate in the rendered graph.</p> </li> <li> <code>highlighted_node_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the indices of the highlighted nodes in the rendered graph.</p> </li> <li> <code>mode</code>               (<code>ViewMode</code>)           \u2013            <p>Get the current view mode.</p> </li> <li> <code>node_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the coordinates of the current view of the nodes in the skeleton graph.</p> </li> <li> <code>node_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the keys of the nodes in the rendered graph.</p> </li> </ul> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def __init__(\n    self,\n    data_manager: \"DataManager\",\n    bounding_box: BoundingBoxData,\n    mode: ViewMode = ViewMode.ALL,\n) -&gt; None:\n    self._data_manager = data_manager\n    self._bounding_box = bounding_box\n    self._mode = mode\n\n    # initialize the data\n    self._edge_coordinates: np.ndarray | None = None\n    self._edge_indices: np.ndarray | None = None\n    self._edge_keys: np.ndarray | None = None\n    self._highlighted_edge_keys: np.ndarray | None = None\n    self._node_coordinates: np.ndarray | None = None\n    self._node_keys: np.ndarray | None = None\n    self._highlighted_node_keys: np.ndarray | None = None\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box: BoundingBoxData\n</code></pre> <p>Get the current bounding box data.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.edge_coordinates","title":"edge_coordinates  <code>property</code>","text":"<pre><code>edge_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the current view of the edges in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge, 3) array of edge coordinates.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.edge_indices","title":"edge_indices  <code>property</code>","text":"<pre><code>edge_indices: ndarray | None\n</code></pre> <p>Get the indices of the current view of the edges in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge indices.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.edge_keys","title":"edge_keys  <code>property</code>","text":"<pre><code>edge_keys: ndarray | None\n</code></pre> <p>Get the keys of the edge for each edge coordinate in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge keys.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.highlighted_edge_keys","title":"highlighted_edge_keys  <code>property</code>","text":"<pre><code>highlighted_edge_keys: ndarray | None\n</code></pre> <p>Get keys of the highlighted edges for each coordinate in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of highlighted edge keys.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.highlighted_node_keys","title":"highlighted_node_keys  <code>property</code>","text":"<pre><code>highlighted_node_keys: ndarray | None\n</code></pre> <p>Get the indices of the highlighted nodes in the rendered graph.</p> <p>(n_highlighted_nodes,) array of node indices.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.mode","title":"mode  <code>property</code> <code>writable</code>","text":"<pre><code>mode: ViewMode\n</code></pre> <p>Get the current view mode.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the current view of the nodes in the skeleton graph.</p> <p>(n_nodes, 3) array of node coordinates.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.node_keys","title":"node_keys  <code>property</code>","text":"<pre><code>node_keys: ndarray | None\n</code></pre> <p>Get the keys of the nodes in the rendered graph.</p> <p>(n_nodes,) array of node keys. These are index-matched with the node_coordinates array.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the data for the currently specified view.</p> <p>This updates the edge coordinates, edge indices, and node indices.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the data for the currently specified view.\n\n    This updates the edge coordinates, edge indices, and node indices.\n    \"\"\"\n    if self._data_manager.skeleton_graph is None:\n        # if the data isn't loaded, nothing to update\n        return\n    if self._mode == ViewMode.ALL:\n        (\n            self._node_coordinates,\n            self._node_keys,\n            self._edge_coordinates,\n            self._edge_indices,\n            self._edge_keys,\n        ) = self._get_view_all()\n        self._highlighted_edge_keys = np.empty((0, 2))\n    elif self._mode == ViewMode.BOUNDING_BOX:\n        (\n            self._node_coordinates,\n            self._node_keys,\n            self._edge_coordinates,\n            self._edge_indices,\n            self._edge_keys,\n        ) = self._get_view_bounding_box()\n        self._highlighted_edge_keys = np.empty((0, 2))\n    else:\n        raise NotImplementedError(f\"View mode {self._mode} not implemented.\")\n\n    # Emit signal that the view data has been updated\n    self.events.data.emit()\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionManager","title":"EdgeSelectionManager","text":"<p>               Bases: <code>EventedModel</code></p> <p>Class to manage selection of edge in the viewer.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionManager(enabled)","title":"<code>enabled</code>","text":"(<code>bool</code>)           \u2013            <p>Set to true if the edge selection is enabled. The default value is False.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionManager(values)","title":"<code>values</code>","text":"(<code>set[tuple[int, int]] | None</code>)           \u2013            <p>The selected edges.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionPasteRequest","title":"EdgeSelectionPasteRequest  <code>dataclass</code>","text":"<pre><code>EdgeSelectionPasteRequest(edge_keys: set[tuple[int, int]])\n</code></pre> <p>Selected edges to paste.</p> <p>This is used for passing selected edges to the paste operation. For example, when pasting edges from the selection to a GUI widget.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionPasteRequest(edge_key)","title":"<code>edge_key</code>","text":"(<code>set[tuple[int, int]]</code>)           \u2013            <p>The keys of the selected edges.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionManager","title":"NodeSelectionManager","text":"<p>               Bases: <code>EventedModel</code></p> <p>Class to manage selection of nodes in the viewer.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionManager(enabled)","title":"<code>enabled</code>","text":"(<code>bool</code>)           \u2013            <p>Set to true if the edge selection is enabled. The default value is False.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionManager(values)","title":"<code>values</code>","text":"(<code>set[int] | None</code>)           \u2013            <p>The selected nodes.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionPasteRequest","title":"NodeSelectionPasteRequest  <code>dataclass</code>","text":"<pre><code>NodeSelectionPasteRequest(node_keys: set[int])\n</code></pre> <p>Selected nodes to paste.</p> <p>This is used for passing selected nodes to the paste operation. For example, when pasting nodes from the selection to a GUI widget.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionPasteRequest(node_keys)","title":"<code>node_keys</code>","text":"(<code>set[int]</code>)           \u2013            <p>The keys of the selected nodes.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SelectionManager","title":"SelectionManager","text":"<p>               Bases: <code>EventedModel</code></p> <p>Class to manage selection of data in the viewer.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths","title":"SkeletonDataPaths","text":"<p>               Bases: <code>EventedModel</code></p> <p>A class storing the state of the skeleton dataset.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>has_paths</code>             \u2013              <p>Returns true if any of the paths are set.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths(image)","title":"<code>image</code>","text":"(<code>FilePath | None</code>)           \u2013            <p>The path to the image file.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths(segmentation)","title":"<code>segmentation</code>","text":"(<code>FilePath | None</code>)           \u2013            <p>The path to the segmentation image file.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>FilePath</code>)           \u2013            <p>The path to the skeleton graph file.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths.has_paths","title":"has_paths","text":"<pre><code>has_paths() -&gt; bool\n</code></pre> <p>Returns true if any of the paths are set.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def has_paths(self) -&gt; bool:\n    \"\"\"Returns true if any of the paths are set.\"\"\"\n    return any([self.image, self.segmentation, self.skeleton_graph])\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.ViewEvents","title":"ViewEvents","text":"<p>               Bases: <code>SignalGroup</code></p> <p>Events for the DataManager class.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.ViewMode","title":"ViewMode","text":"<p>               Bases: <code>Enum</code></p> <p>The different viewing modes.</p> <p>ALL: Show all data. BOUNDING_BOX: Show data in a specified bounding box. NODE: Show data around a specified node.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.ViewRequest","title":"ViewRequest  <code>dataclass</code>","text":"<pre><code>ViewRequest()\n</code></pre> <p>Base Request to view data in the skeleton graph.</p> <p>Do not use this class directly, use one of the subclasses instead.</p>"},{"location":"reference/skeleplex/app/_utils/","title":"_utils","text":""},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils","title":"skeleplex.app._utils","text":"<p>Functions:</p> <ul> <li> <code>run</code>             \u2013              <p>Start the Qt application event loop.</p> </li> <li> <code>should_launch_ipython_event_loop</code>             \u2013              <p>Check if the IPython Qt event loop should be launched.</p> </li> <li> <code>start_qt_loop_ipython</code>             \u2013              <p>Start the Qt event loop in an IPython environment.</p> </li> <li> <code>view_skeleton</code>             \u2013              <p>Launch the skeleton viewer application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Start the Qt application event loop.</p> <p>This is meant to be used in a script. This should be called after the viewer is set up.</p> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def run():\n    \"\"\"Start the Qt application event loop.\n\n    This is meant to be used in a script.\n    This should be called after the viewer is set up.\n    \"\"\"\n    # get the qapplication instance\n    qapp = QApplication.instance() or QApplication([])\n\n    # start the Qt application event loop\n    qapp.exec_()\n</code></pre>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.should_launch_ipython_event_loop","title":"should_launch_ipython_event_loop","text":"<pre><code>should_launch_ipython_event_loop() -&gt; bool\n</code></pre> <p>Check if the IPython Qt event loop should be launched.</p> <p>This means that we are both in an IPython environment and the event loop is not already running.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if running in IPython and the loop is needed. False otherwise.</p> </li> </ul> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def should_launch_ipython_event_loop() -&gt; bool:\n    \"\"\"\n    Check if the IPython Qt event loop should be launched.\n\n    This means that we are both in an IPython environment and the\n    event loop is not already running.\n\n    Returns\n    -------\n    bool\n        True if running in IPython and the loop is needed.\n        False otherwise.\n    \"\"\"\n    shell = get_ipython()\n\n    if not shell:\n        # not in IPython environment\n        return False\n\n    return not shell.active_eventloop == \"qt\"\n</code></pre>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.start_qt_loop_ipython","title":"start_qt_loop_ipython","text":"<pre><code>start_qt_loop_ipython()\n</code></pre> <p>Start the Qt event loop in an IPython environment.</p> <p>This works for both jupyter and ipython console environments.</p> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def start_qt_loop_ipython():\n    \"\"\"Start the Qt event loop in an IPython environment.\n\n    This works for both jupyter and ipython console environments.\n    \"\"\"\n    ipython = get_ipython()\n    ipython.enable_gui(\"qt\")\n</code></pre>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.view_skeleton","title":"view_skeleton","text":"<pre><code>view_skeleton(graph_path: str)\n</code></pre> <p>Launch the skeleton viewer application.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SkelePlexApp</code>           \u2013            <p>The SkelePlex application instance for viewing the skeleton.</p> </li> </ul> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def view_skeleton(\n    graph_path: str,\n):\n    \"\"\"Launch the skeleton viewer application.\n\n    Parameters\n    ----------\n    graph_path : str\n        Path to the skeleton graph JSON file.\n\n    Returns\n    -------\n    SkelePlexApp\n        The SkelePlex application instance for viewing the skeleton.\n    \"\"\"\n    global _app_ref\n\n    # get the qapplication instance\n    qapp = QApplication.instance() or QApplication([])\n\n    # Store reference to prevent garbage collection\n    _app_ref = qapp\n\n    # load the data\n    data_manager = DataManager(file_paths=SkeletonDataPaths(skeleton_graph=graph_path))\n\n    # make the viewer\n    viewer = SkelePlexApp(data=data_manager)\n    viewer.show()\n\n    # Wait a short time for things to load and then look at the skeleton\n    # this is a hack...do something smarter later\n    timer = QTimer()\n    timer.singleShot(100, viewer.look_at_skeleton)\n\n    # start the Qt event loop if in Jupyter/IPython\n    if should_launch_ipython_event_loop():\n        start_qt_loop_ipython()\n\n    return viewer\n</code></pre>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.view_skeleton(graph_path)","title":"<code>graph_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the skeleton graph JSON file.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/","title":"_viewer_controller","text":""},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller","title":"skeleplex.app._viewer_controller","text":"<p>Classes for interfacing with the viewer.</p> <p>Classes:</p> <ul> <li> <code>MainCanvasController</code>           \u2013            <p>A class for controlling the main canvas.</p> </li> <li> <code>RenderedSkeletonComponents</code>           \u2013            <p>A class for storing the components for a rendered skeleton.</p> </li> <li> <code>ViewerController</code>           \u2013            <p>A class for controlling the viewer backend.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController","title":"MainCanvasController","text":"<pre><code>MainCanvasController(scene_id: str, backend: CellierController)\n</code></pre> <p>A class for controlling the main canvas.</p> <p>Methods:</p> <ul> <li> <code>add_skeleton_edge_callback</code>             \u2013              <p>Add a callback to the skeleton edge visual.</p> </li> <li> <code>add_skeleton_node_callback</code>             \u2013              <p>Add a callback to the skeleton node visual.</p> </li> <li> <code>look_at_skeleton</code>             \u2013              <p>Adjust the camera to look at the skeleton.</p> </li> <li> <code>remove_skeleton_edge_callback</code>             \u2013              <p>Remove a callback from the skeleton edge visual.</p> </li> <li> <code>remove_skeleton_node_callback</code>             \u2013              <p>Remove a callback from the skeleton node visual.</p> </li> <li> <code>set_edge_highlight</code>             \u2013              <p>Set the edge highlight coordinates.</p> </li> <li> <code>set_node_highlight</code>             \u2013              <p>Set the node highlight coordinates.</p> </li> <li> <code>update_skeleton_geometry</code>             \u2013              <p>Update the geometry of the skeleton in the viewer.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>scene_id</code>               (<code>str</code>)           \u2013            <p>Get the scene ID of the main canvas.</p> </li> </ul> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def __init__(self, scene_id: str, backend: CellierController):\n    self._scene_id = scene_id\n    self._backend = backend\n\n    # this will store the rendered skeleton components\n    self._skeleton = RenderedSkeletonComponents()\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.scene_id","title":"scene_id  <code>property</code>","text":"<pre><code>scene_id: str\n</code></pre> <p>Get the scene ID of the main canvas.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_edge_callback","title":"add_skeleton_edge_callback","text":"<pre><code>add_skeleton_edge_callback(callback: Callable)\n</code></pre> <p>Add a callback to the skeleton edge visual.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def add_skeleton_edge_callback(\n    self,\n    callback: Callable,\n):\n    \"\"\"Add a callback to the skeleton edge visual.\n\n    Parameters\n    ----------\n    callback : Callable\n        The callback function.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    # add for the data visual\n    if (\n        self._skeleton.edges_visual.id\n        not in self._backend.events.mouse.visual_signals\n    ):\n        # if the visual isn't registered, register it\n        self._backend.events.mouse.register_visual(\n            visual_id=self._skeleton.edges_visual.id\n        )\n    self._backend.events.mouse.subscribe_to_visual(\n        visual_id=self._skeleton.edges_visual.id,\n        callback=partial(callback, click_source=\"data\"),\n    )\n\n    # add for the highlight visual\n    if (\n        self._skeleton.edge_highlight_visual.id\n        not in self._backend.events.mouse.visual_signals\n    ):\n        # if the visual isn't registered, register it\n        self._backend.events.mouse.register_visual(\n            visual_id=self._skeleton.edge_highlight_visual.id\n        )\n    self._backend.events.mouse.subscribe_to_visual(\n        visual_id=self._skeleton.edge_highlight_visual.id,\n        callback=partial(callback, click_source=\"highlight\"),\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_edge_callback(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>)           \u2013            <p>The callback function.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_node_callback","title":"add_skeleton_node_callback","text":"<pre><code>add_skeleton_node_callback(callback: Callable)\n</code></pre> <p>Add a callback to the skeleton node visual.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def add_skeleton_node_callback(self, callback: Callable):\n    \"\"\"Add a callback to the skeleton node visual.\n\n    Parameters\n    ----------\n    callback : Callable\n        The callback function.\n    callback_type : tuple[str, ...]\n        The type of callback. See the pygfx documentation for event types.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    # add for the data visual\n    if (\n        self._skeleton.node_visual.id\n        not in self._backend.events.mouse.visual_signals\n    ):\n        # if the visual isn't registered, register it\n        self._backend.events.mouse.register_visual(\n            visual_id=self._skeleton.node_visual.id\n        )\n    self._backend.events.mouse.subscribe_to_visual(\n        visual_id=self._skeleton.node_visual.id,\n        callback=partial(callback, click_source=\"data\"),\n    )\n\n    # add for the highlight visual\n    if (\n        self._skeleton.node_highlight_visual.id\n        not in self._backend.events.mouse.visual_signals\n    ):\n        # if the visual isn't registered, register it\n        self._backend.events.mouse.register_visual(\n            visual_id=self._skeleton.node_highlight_visual.id\n        )\n        self._backend.events.mouse.subscribe_to_visual(\n            visual_id=self._skeleton.node_highlight_visual.id,\n            callback=partial(callback, click_source=\"highlight\"),\n        )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_node_callback(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>)           \u2013            <p>The callback function.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_node_callback(callback_type)","title":"<code>callback_type</code>","text":"(<code>tuple[str, ...]</code>)           \u2013            <p>The type of callback. See the pygfx documentation for event types.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.look_at_skeleton","title":"look_at_skeleton","text":"<pre><code>look_at_skeleton(view_direction: tuple[int, int, int] = (0, 0, 1), up: tuple[int, int, int] = (0, 1, 0))\n</code></pre> <p>Adjust the camera to look at the skeleton.</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def look_at_skeleton(\n    self,\n    view_direction: tuple[int, int, int] = (0, 0, 1),\n    up: tuple[int, int, int] = (0, 1, 0),\n):\n    \"\"\"Adjust the camera to look at the skeleton.\"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._backend.look_at_visual(\n        visual_id=self._skeleton.node_visual.id,\n        view_direction=view_direction,\n        up=up,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_edge_callback","title":"remove_skeleton_edge_callback","text":"<pre><code>remove_skeleton_edge_callback(callback: Callable)\n</code></pre> <p>Remove a callback from the skeleton edge visual.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def remove_skeleton_edge_callback(self, callback: Callable):\n    \"\"\"Remove a callback from the skeleton edge visual.\n\n    Parameters\n    ----------\n    callback : Callable\n        The callback function.\n    callback_type : tuple[str, ...]\n        The type of callback. See the pygfx documentation for event types.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._backend.remove_visual_callback(\n        visual_id=self._skeleton.edges_visual.id,\n        callback=callback,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_edge_callback(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>)           \u2013            <p>The callback function.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_edge_callback(callback_type)","title":"<code>callback_type</code>","text":"(<code>tuple[str, ...]</code>)           \u2013            <p>The type of callback. See the pygfx documentation for event types.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_node_callback","title":"remove_skeleton_node_callback","text":"<pre><code>remove_skeleton_node_callback(callback: Callable)\n</code></pre> <p>Remove a callback from the skeleton node visual.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def remove_skeleton_node_callback(self, callback: Callable):\n    \"\"\"Remove a callback from the skeleton node visual.\n\n    Parameters\n    ----------\n    callback : Callable\n        The callback function.\n    callback_type : tuple[str, ...]\n        The type of callback. See the pygfx documentation for event types.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._backend.remove_visual_callback(\n        visual_id=self._skeleton.node_visual.id,\n        callback=callback,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_node_callback(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>)           \u2013            <p>The callback function.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_node_callback(callback_type)","title":"<code>callback_type</code>","text":"(<code>tuple[str, ...]</code>)           \u2013            <p>The type of callback. See the pygfx documentation for event types.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.set_edge_highlight","title":"set_edge_highlight","text":"<pre><code>set_edge_highlight(edge_coordinates: ndarray)\n</code></pre> <p>Set the edge highlight coordinates.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def set_edge_highlight(\n    self,\n    edge_coordinates: np.ndarray,\n):\n    \"\"\"Set the edge highlight coordinates.\n\n    Parameters\n    ----------\n    edge_coordinates : np.ndarray\n        The coordinates of the edge to highlight.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._skeleton.edge_highlight_store.coordinates = edge_coordinates.astype(\n        np.float32\n    )\n    self._backend.reslice_scene(scene_id=self.scene_id)\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.set_edge_highlight(edge_coordinates)","title":"<code>edge_coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates of the edge to highlight.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.set_node_highlight","title":"set_node_highlight","text":"<pre><code>set_node_highlight(node_coordinates: ndarray) -&gt; None\n</code></pre> <p>Set the node highlight coordinates.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def set_node_highlight(\n    self,\n    node_coordinates: np.ndarray,\n) -&gt; None:\n    \"\"\"Set the node highlight coordinates.\n\n    Parameters\n    ----------\n    node_coordinates : np.ndarray\n        The coordinates of the node to highlight.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._skeleton.node_highlight_store.coordinates = node_coordinates.astype(\n        np.float32\n    )\n    self._backend.reslice_scene(scene_id=self.scene_id)\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.set_node_highlight(node_coordinates)","title":"<code>node_coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates of the node to highlight.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.update_skeleton_geometry","title":"update_skeleton_geometry","text":"<pre><code>update_skeleton_geometry(edge_coordinates: ndarray, node_coordinates: ndarray)\n</code></pre> <p>Update the geometry of the skeleton in the viewer.</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def update_skeleton_geometry(\n    self, edge_coordinates: np.ndarray, node_coordinates: np.ndarray\n):\n    \"\"\"Update the geometry of the skeleton in the viewer.\"\"\"\n    # make the highlight lines store\n    if self._skeleton.edge_highlight_store is None:\n        # if the highlight store is not populated, create it\n        self._skeleton.edge_highlight_store = LinesMemoryStore(\n            coordinates=np.empty((0, 3))\n        )\n        self._backend.add_data_store(data_store=self._skeleton.edge_highlight_store)\n\n    if self._skeleton.edge_highlight_visual is None:\n        # if the highlight visual is not populated, create it\n        edge_highlight_material_3d = LinesUniformMaterial(\n            color=(1, 0, 1, 1), size=6, size_coordinate_space=\"data\", opacity=1.0\n        )\n\n        # make the highlight lines model\n        edge_highlight_visual = LinesVisual(\n            name=\"edge_highlight\",\n            data_store_id=self._skeleton.edge_highlight_store.id,\n            material=edge_highlight_material_3d,\n            pick_write=True,\n        )\n        self._skeleton.edge_highlight_visual = edge_highlight_visual\n\n        # add the visual model to the viewer\n        self._backend.add_visual(\n            visual_model=edge_highlight_visual, scene_id=self.scene_id\n        )\n\n    # update the lines store\n    if self._skeleton.edges_store is None:\n        self._skeleton.edges_store = LinesMemoryStore(coordinates=edge_coordinates)\n        self._backend.add_data_store(data_store=self._skeleton.edges_store)\n    else:\n        self._skeleton.edges_store.coordinates = edge_coordinates.astype(np.float32)\n\n    if self._skeleton.edges_visual is None:\n        # if the lines visual is not populated, create it\n        edge_lines_material_3d = LinesUniformMaterial(\n            color=(0, 0, 1, 1), size=2, size_coordinate_space=\"data\"\n        )\n\n        # make the lines model\n        edge_lines_visual = LinesVisual(\n            name=\"edge_lines\",\n            data_store_id=self._skeleton.edges_store.id,\n            material=edge_lines_material_3d,\n        )\n        self._skeleton.edges_visual = edge_lines_visual\n        self._backend.add_visual(\n            visual_model=edge_lines_visual, scene_id=self.scene_id\n        )\n\n    if self._skeleton.node_highlight_store is None:\n        # make the highlight points store if it is not already created\n        self._skeleton.node_highlight_store = PointsMemoryStore(\n            coordinates=np.empty((0, 3), dtype=np.float32)\n        )\n        self._backend.add_data_store(data_store=self._skeleton.node_highlight_store)\n\n    if self._skeleton.node_highlight_visual is None:\n        # make the highlight points material\n        highlight_points_material_3d = PointsUniformMaterial(\n            size=20, color=(0, 1, 0, 1), size_coordinate_space=\"data\"\n        )\n\n        # make the highlight points model\n        highlight_points_visual_3d = PointsVisual(\n            name=\"node_highlight_points\",\n            data_store_id=self._skeleton.node_highlight_store.id,\n            material=highlight_points_material_3d,\n        )\n        self._skeleton.node_highlight_visual = highlight_points_visual_3d\n\n        # add the highlights to the viewer\n        self._backend.add_visual(\n            visual_model=highlight_points_visual_3d, scene_id=self.scene_id\n        )\n\n    if self._skeleton.node_store is None:\n        # make the points store if it is not already created\n        self._skeleton.node_store = PointsMemoryStore(coordinates=node_coordinates)\n        self._backend.add_data_store(data_store=self._skeleton.node_store)\n    else:\n        # update the points store with the new coordinates\n        self._skeleton.node_store.coordinates = node_coordinates.astype(np.float32)\n\n    if self._skeleton.node_visual is None:\n        # make the points material\n        points_material_3d = PointsUniformMaterial(\n            size=8, color=(0, 0, 0, 1), size_coordinate_space=\"data\"\n        )\n\n        # make the points model\n        points_visual_3d = PointsVisual(\n            name=\"node_points\",\n            data_store_id=self._skeleton.node_store.id,\n            material=points_material_3d,\n        )\n        self._skeleton.node_visual = points_visual_3d\n        self._backend.add_visual(\n            visual_model=points_visual_3d, scene_id=self.scene_id\n        )\n\n    # reslice the scene\n    self._backend.reslice_scene(scene_id=self.scene_id)\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.RenderedSkeletonComponents","title":"RenderedSkeletonComponents  <code>dataclass</code>","text":"<pre><code>RenderedSkeletonComponents(node_store: PointsMemoryStore | None = None, node_visual: PointsVisual | None = None, node_highlight_store: PointsMemoryStore | None = None, node_highlight_visual: PointsVisual | None = None, edges_store: LinesMemoryStore | None = None, edges_visual: LinesVisual | None = None, edge_highlight_store: LinesMemoryStore | None = None, edge_highlight_visual: LinesVisual | None = None)\n</code></pre> <p>A class for storing the components for a rendered skeleton.</p> <p>These data are used for accessing the rendered skeleton in the viewer backend.</p> <p>Methods:</p> <ul> <li> <code>populated</code>             \u2013              <p>Returns True if all the components are populated.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.RenderedSkeletonComponents.populated","title":"populated","text":"<pre><code>populated() -&gt; bool\n</code></pre> <p>Returns True if all the components are populated.</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def populated(self) -&gt; bool:\n    \"\"\"Returns True if all the components are populated.\"\"\"\n    return all(\n        [\n            self.node_store is not None,\n            self.node_visual is not None,\n            self.node_highlight_store is not None,\n            self.node_highlight_visual is not None,\n            self.edges_store is not None,\n            self.edges_visual is not None,\n            self.edge_highlight_store is not None,\n            self.edge_highlight_visual is not None,\n        ]\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.ViewerController","title":"ViewerController","text":"<pre><code>ViewerController(parent_widget: QWidget)\n</code></pre> <p>A class for controlling the viewer backend.</p> <p>Attributes:</p> <ul> <li> <code>main_canvas</code>               (<code>MainCanvasController</code>)           \u2013            <p>Get the controller for the main canvas.</p> </li> </ul> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def __init__(self, parent_widget: \"QWidget\"):\n    viewer_model, main_canvas_scene_id = make_viewer_model()\n    self._backend = make_viewer_controller(\n        viewer_model=viewer_model, parent_widget=parent_widget\n    )\n\n    # make the main canvas controller\n    self._main_canvas = MainCanvasController(\n        scene_id=main_canvas_scene_id, backend=self._backend\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.ViewerController.main_canvas","title":"main_canvas  <code>property</code>","text":"<pre><code>main_canvas: MainCanvasController\n</code></pre> <p>Get the controller for the main canvas.</p>"},{"location":"reference/skeleplex/app/actions/","title":"actions","text":""},{"location":"reference/skeleplex/app/actions/#skeleplex.app.actions","title":"skeleplex.app.actions","text":"<p>Actions to be registered for the application.</p>"},{"location":"reference/skeleplex/app/functions/","title":"functions","text":""},{"location":"reference/skeleplex/app/functions/#skeleplex.app.functions","title":"skeleplex.app.functions","text":"<p>Functions for the app.</p> <p>Functions:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the active window.</p> </li> </ul>"},{"location":"reference/skeleplex/app/functions/#skeleplex.app.functions.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the active window.</p> Source code in <code>skeleplex/app/functions.py</code> <pre><code>def close():\n    \"\"\"Close the active window.\"\"\"\n    QApplication.activeWindow().close()\n    print(\"close\")\n</code></pre>"},{"location":"reference/skeleplex/app/cellier/","title":"cellier","text":""},{"location":"reference/skeleplex/app/cellier/#skeleplex.app.cellier","title":"skeleplex.app.cellier","text":"<p>Cellier rendering module.</p> <p>Modules:</p> <ul> <li> <code>utils</code>           \u2013            <p>Viewer controller for the Cellier renderer.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>make_viewer_controller</code>             \u2013              <p>Make the viewer controller.</p> </li> <li> <code>make_viewer_model</code>             \u2013              <p>Make the viewer controller.</p> </li> </ul>"},{"location":"reference/skeleplex/app/cellier/#skeleplex.app.cellier.make_viewer_controller","title":"make_viewer_controller","text":"<pre><code>make_viewer_controller(viewer_model: ViewerModel, parent_widget: QWidget) -&gt; CellierController\n</code></pre> <p>Make the viewer controller.</p> Source code in <code>skeleplex/app/cellier/utils.py</code> <pre><code>def make_viewer_controller(\n    viewer_model: ViewerModel, parent_widget: QWidget\n) -&gt; CellierController:\n    \"\"\"Make the viewer controller.\"\"\"\n    return CellierController(\n        model=viewer_model,\n        slicer_type=SlicerType.ASYNCHRONOUS,\n        widget_parent=parent_widget,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/cellier/#skeleplex.app.cellier.make_viewer_model","title":"make_viewer_model","text":"<pre><code>make_viewer_model() -&gt; tuple[ViewerModel, str]\n</code></pre> <p>Make the viewer controller.</p> Source code in <code>skeleplex/app/cellier/utils.py</code> <pre><code>def make_viewer_model() -&gt; tuple[ViewerModel, str]:\n    \"\"\"Make the viewer controller.\"\"\"\n    # make the data manager (empty for now)\n    data_manager = DataManager(stores={})\n\n    # make the scene coordinate system\n    coordinate_system_3d = CoordinateSystem(\n        name=\"scene_3d\", axis_labels=(\"z\", \"y\", \"x\")\n    )\n    dims_3d = DimsManager(\n        coordinate_system=coordinate_system_3d,\n        range=(RangeTuple(0, 100, 1), RangeTuple(0, 100, 1), RangeTuple(0, 100, 1)),\n        selection=AxisAlignedRegionSelector(\n            space_type=CoordinateSpace.WORLD,\n            ordered_dims=(0, 1, 2),\n            n_displayed_dims=3,\n            index_selection=(slice(None, None), slice(None, None), slice(None, None)),\n        ),\n    )\n\n    # make the canvas\n    controller = TrackballCameraController(enabled=True)\n    camera_3d = PerspectiveCamera(controller=controller)\n    canvas_3d = Canvas(camera=camera_3d)\n\n    # make the scene\n    main_viewer_scene = Scene(\n        dims=dims_3d, visuals=[], canvases={canvas_3d.id: canvas_3d}\n    )\n\n    scene_manager = SceneManager(scenes={main_viewer_scene.id: main_viewer_scene})\n\n    # make the viewer model\n    viewer_model = ViewerModel(data=data_manager, scenes=scene_manager)\n\n    return viewer_model, main_viewer_scene.id\n</code></pre>"},{"location":"reference/skeleplex/app/cellier/utils/","title":"utils","text":""},{"location":"reference/skeleplex/app/cellier/utils/#skeleplex.app.cellier.utils","title":"skeleplex.app.cellier.utils","text":"<p>Viewer controller for the Cellier renderer.</p> <p>Functions:</p> <ul> <li> <code>make_viewer_controller</code>             \u2013              <p>Make the viewer controller.</p> </li> <li> <code>make_viewer_model</code>             \u2013              <p>Make the viewer controller.</p> </li> </ul>"},{"location":"reference/skeleplex/app/cellier/utils/#skeleplex.app.cellier.utils.make_viewer_controller","title":"make_viewer_controller","text":"<pre><code>make_viewer_controller(viewer_model: ViewerModel, parent_widget: QWidget) -&gt; CellierController\n</code></pre> <p>Make the viewer controller.</p> Source code in <code>skeleplex/app/cellier/utils.py</code> <pre><code>def make_viewer_controller(\n    viewer_model: ViewerModel, parent_widget: QWidget\n) -&gt; CellierController:\n    \"\"\"Make the viewer controller.\"\"\"\n    return CellierController(\n        model=viewer_model,\n        slicer_type=SlicerType.ASYNCHRONOUS,\n        widget_parent=parent_widget,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/cellier/utils/#skeleplex.app.cellier.utils.make_viewer_model","title":"make_viewer_model","text":"<pre><code>make_viewer_model() -&gt; tuple[ViewerModel, str]\n</code></pre> <p>Make the viewer controller.</p> Source code in <code>skeleplex/app/cellier/utils.py</code> <pre><code>def make_viewer_model() -&gt; tuple[ViewerModel, str]:\n    \"\"\"Make the viewer controller.\"\"\"\n    # make the data manager (empty for now)\n    data_manager = DataManager(stores={})\n\n    # make the scene coordinate system\n    coordinate_system_3d = CoordinateSystem(\n        name=\"scene_3d\", axis_labels=(\"z\", \"y\", \"x\")\n    )\n    dims_3d = DimsManager(\n        coordinate_system=coordinate_system_3d,\n        range=(RangeTuple(0, 100, 1), RangeTuple(0, 100, 1), RangeTuple(0, 100, 1)),\n        selection=AxisAlignedRegionSelector(\n            space_type=CoordinateSpace.WORLD,\n            ordered_dims=(0, 1, 2),\n            n_displayed_dims=3,\n            index_selection=(slice(None, None), slice(None, None), slice(None, None)),\n        ),\n    )\n\n    # make the canvas\n    controller = TrackballCameraController(enabled=True)\n    camera_3d = PerspectiveCamera(controller=controller)\n    canvas_3d = Canvas(camera=camera_3d)\n\n    # make the scene\n    main_viewer_scene = Scene(\n        dims=dims_3d, visuals=[], canvases={canvas_3d.id: canvas_3d}\n    )\n\n    scene_manager = SceneManager(scenes={main_viewer_scene.id: main_viewer_scene})\n\n    # make the viewer model\n    viewer_model = ViewerModel(data=data_manager, scenes=scene_manager)\n\n    return viewer_model, main_viewer_scene.id\n</code></pre>"},{"location":"reference/skeleplex/app/qt/","title":"qt","text":""},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt","title":"skeleplex.app.qt","text":"<p>Qt widgets for the SkelePlex app.</p> <p>Modules:</p> <ul> <li> <code>app_controls</code>           \u2013            <p>Dock widget for the Application Controls.</p> </li> <li> <code>auxiliary_views</code>           \u2013            <p>Dock widget to hold additional views of the data.</p> </li> <li> <code>flat_group_box</code>           \u2013            <p>A flat-styled group box widget.</p> </li> <li> <code>main_viewer</code>           \u2013            <p>Widgets for the main viewer.</p> </li> <li> <code>styles</code>           \u2013            <p>QSS styles for the application.</p> </li> <li> <code>window</code>           \u2013            <p>Qt implementation of the main window for the application.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>AppControlsDock</code>           \u2013            <p>A dock widget for the application controls.</p> </li> <li> <code>AuxiliaryViews</code>           \u2013            <p>A dock widget for the auxiliary views.</p> </li> <li> <code>MainWindow</code>           \u2013            <p>Qt + app-model implementation of the main window for the application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt.AppControlsDock","title":"AppControlsDock","text":"<pre><code>AppControlsDock(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QDockWidget</code></p> <p>A dock widget for the application controls.</p> <p>This will be used as a container GUI elements for controlling the state of the application.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n    self.setStyleSheet(DOCK_WIDGET_STYLE)\n    self.setWidget(AppControlsWidget(parent=self))\n</code></pre>"},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt.AuxiliaryViews","title":"AuxiliaryViews","text":"<pre><code>AuxiliaryViews(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QDockWidget</code></p> <p>A dock widget for the auxiliary views.</p> <p>This will hold things like a view of slices along a spline.</p> Source code in <code>skeleplex/app/qt/auxiliary_views.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n    self.setStyleSheet(DOCK_WIDGET_STYLE)\n\n    self.label = QLabel(\"I'm the Auxiliary Views\")\n    self.label.setMinimumWidth(self.MINIMUM_WIDTH)\n\n    self.setWidget(self.label)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt.MainWindow","title":"MainWindow","text":"<pre><code>MainWindow(app: Application)\n</code></pre> <p>               Bases: <code>QModelMainWindow</code></p> <p>Qt + app-model implementation of the main window for the application.</p> <p>Methods:</p> <ul> <li> <code>add_auxiliary_widget</code>             \u2013              <p>Add a widget to the auxiliary views dock.</p> </li> </ul> Source code in <code>skeleplex/app/qt/window.py</code> <pre><code>def __init__(self, app: Application):\n    super().__init__(app)\n\n    # set the background color\n    self.setStyleSheet(MAIN_WINDOW_STYLE)\n\n    # self.tool_bar = self.addModelToolBar(MenuId.FILE, exclude={CommandId.OPEN})\n    # self.tool_bar.setStyleSheet(\"background: white;\")\n\n    # set the central widget\n    self.setCentralWidget(QLabel(\"I'm the Central Widget\"))\n\n    # set the minimum window size - app will launch with this size.\n    self.setMinimumSize(MIN_WINDOW_WIDTH, MIN_WINDOW_HEIGHT)\n\n    # Create the app controls as a dock widget (left)\n    self._create_app_controls()\n\n    # create the auxiliary views as a dock widget (right)\n    self._create_auxiliary_views()\n\n    # create the status bar at the bottom of the window\n    self._create_status_bar()\n</code></pre>"},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt.MainWindow.add_auxiliary_widget","title":"add_auxiliary_widget","text":"<pre><code>add_auxiliary_widget(widget: QWidget, name: str = '')\n</code></pre> <p>Add a widget to the auxiliary views dock.</p> Source code in <code>skeleplex/app/qt/window.py</code> <pre><code>def add_auxiliary_widget(self, widget: QWidget, name: str = \"\"):\n    \"\"\"Add a widget to the auxiliary views dock.\"\"\"\n    dock_widget = QDockWidget(name)\n    dock_widget.setWidget(widget)\n    self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, dock_widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/","title":"app_controls","text":""},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls","title":"skeleplex.app.qt.app_controls","text":"<p>Dock widget for the Application Controls.</p> <p>Classes:</p> <ul> <li> <code>AppControlsDock</code>           \u2013            <p>A dock widget for the application controls.</p> </li> <li> <code>AppControlsWidget</code>           \u2013            <p>A widget for the application controls.</p> </li> <li> <code>DataSelectorWidget</code>           \u2013            <p>A widget for selecting data from the main viewer.</p> </li> <li> <code>DataViewWidget</code>           \u2013            <p>A widget for selecting which regions of the data are in view.</p> </li> <li> <code>SelectionModeWidget</code>           \u2013            <p>Widget for controlling a selection mode.</p> </li> <li> <code>ViewAllModeControls</code>           \u2013            <p>A widget for controlling the view all mode.</p> </li> <li> <code>ViewBoundingBoxControls</code>           \u2013            <p>A widget for controlling the bounding box view mode.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.AppControlsDock","title":"AppControlsDock","text":"<pre><code>AppControlsDock(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QDockWidget</code></p> <p>A dock widget for the application controls.</p> <p>This will be used as a container GUI elements for controlling the state of the application.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n    self.setStyleSheet(DOCK_WIDGET_STYLE)\n    self.setWidget(AppControlsWidget(parent=self))\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.AppControlsWidget","title":"AppControlsWidget","text":"<pre><code>AppControlsWidget(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>A widget for the application controls.</p> <p>This is the widget embedded in the AppControlsDock.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n\n    self.load_data_widget = magicgui(self._load_data_gui)\n    stores_box = FlatVGroupBox(\n        \"Data Stores\", accent_color=\"#b7e2d8\", collapsible=True, parent=self\n    )\n    stores_box.add_widget(self.load_data_widget.native)\n\n    # widget for selecting the data view\n    self.view_box = DataViewWidget(\n        collapsible=True,\n        parent=self,\n    )\n\n    # widget for selecting the data selection mode\n    self.selection_box = DataSelectorWidget(collapsible=True, parent=self)\n\n    # make the layout\n    layout = QVBoxLayout()\n    layout.addWidget(stores_box)\n    layout.addWidget(self.view_box)\n    layout.addWidget(self.selection_box)\n    layout.addStretch()\n\n    layout.setAlignment(Qt.AlignTop)\n\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataSelectorWidget","title":"DataSelectorWidget","text":"<pre><code>DataSelectorWidget(collapsible: bool = False, parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>FlatHGroupBox</code></p> <p>A widget for selecting data from the main viewer.</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, collapsible: bool = False, parent: QWidget | None = None):\n    super().__init__(\n        title=\"Data Selector\",\n        accent_color=\"#cab8c4\",\n        collapsible=collapsible,\n        parent=parent,\n    )\n\n    self.edge_mode_box = SelectionModeWidget(title=\"Edge\", parent=self)\n    self.node_mode_box = SelectionModeWidget(title=\"Node\", parent=self)\n\n    # Add the widgets\n    self.add_widget(self.edge_mode_box)\n    self.add_widget(self.node_mode_box)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataSelectorWidget.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataSelectorWidget.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataViewWidget","title":"DataViewWidget","text":"<pre><code>DataViewWidget(collapsible: bool = False, parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>FlatHGroupBox</code></p> <p>A widget for selecting which regions of the data are in view.</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, collapsible: bool = False, parent: QWidget | None = None):\n    super().__init__(\n        title=\"Data View\",\n        accent_color=\"#b7e2d8\",\n        collapsible=collapsible,\n        parent=parent,\n    )\n\n    # buttons for the mode\n    self.mode_buttons = QButtonGroup(parent=self)\n    self.all_button = QRadioButton(\"All\", parent=self)\n    self.all_button.setChecked(True)\n    self.bounding_box_button = QRadioButton(\"Bounding box\", parent=self)\n    self.mode_buttons.addButton(self.all_button)\n    self.mode_buttons.addButton(self.bounding_box_button)\n    self.mode_buttons.setExclusive(True)\n    self.button_box = QGroupBox(title=\"View mode\", parent=self)\n    self.button_box.setStyleSheet(GROUP_BOX_STYLE)\n    layout = QVBoxLayout()\n    layout.addWidget(self.all_button)\n    layout.addWidget(self.bounding_box_button)\n    self.button_box.setAutoFillBackground(True)\n    self.button_box.setLayout(layout)\n\n    # Make the view all widget\n    self.view_all_controls = ViewAllModeControls(parent=self)\n\n    # make the view bounding box widget\n    self.view_bounding_box_controls = ViewBoundingBoxControls(parent=self)\n    self.view_bounding_box_controls.setVisible(False)\n\n    # connect the view all event\n    self.view_all_controls.render_requested.connect(self._on_view_requested)\n\n    # connect the view bounding box event\n    self.view_bounding_box_controls.bounding_box_widget.called.connect(\n        self._on_view_requested\n    )\n\n    # connect the mode buttons\n    self.mode_buttons.buttonClicked.connect(self._on_mode_changed)\n\n    # Add the widgets\n    self.add_widget(self.button_box)\n    self.add_widget(self.view_all_controls)\n    self.add_widget(self.view_bounding_box_controls)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataViewWidget.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataViewWidget.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.SelectionModeWidget","title":"SelectionModeWidget","text":"<pre><code>SelectionModeWidget(title: str = '', parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QGroupBox</code></p> <p>Widget for controlling a selection mode.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, title: str = \"\", parent: QWidget | None = None):\n    super().__init__(title=title, parent=parent)\n\n    self.enable_checkbox = QCheckBox(\"Enable\")\n    self.selection_box = QLineEdit()\n\n    # Make the layout\n    layout = QHBoxLayout()\n    layout.addWidget(self.enable_checkbox)\n    layout.addWidget(self.selection_box)\n    self.setLayout(layout)\n\n    # set the style\n    self.setStyleSheet(GROUP_BOX_STYLE)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.ViewAllModeControls","title":"ViewAllModeControls","text":"<pre><code>ViewAllModeControls(parent=None)\n</code></pre> <p>               Bases: <code>QGroupBox</code></p> <p>A widget for controlling the view all mode.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent=None):\n    super().__init__(title=\"View all controls\", parent=parent)\n\n    # button to render the view\n    self.render_button = QPushButton(\"Render\", parent=self)\n\n    # connect the button click event\n    self.render_button.clicked.connect(self._on_render_button_clicked)\n\n    # make the layout\n    layout = QVBoxLayout()\n    layout.addWidget(self.render_button)\n    self.setLayout(layout)\n\n    # set the style\n    self.setStyleSheet(GROUP_BOX_STYLE)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.ViewBoundingBoxControls","title":"ViewBoundingBoxControls","text":"<pre><code>ViewBoundingBoxControls(parent=None)\n</code></pre> <p>               Bases: <code>QGroupBox</code></p> <p>A widget for controlling the bounding box view mode.</p> <p>Methods:</p> <ul> <li> <code>update_bounding_box</code>             \u2013              <p>Update the bounding box controls with new minimum and maximum values.</p> </li> </ul> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent=None):\n    super().__init__(title=\"Bounding box controls\", parent=parent)\n\n    # make widget for setting bounding box\n    self.bounding_box_widget = magicgui(\n        self.update_bounding_box,\n        call_button=\"Render\",\n        minimum={\"options\": {\"max\": sys.float_info.max}},\n        maximum={\"options\": {\"max\": sys.float_info.max}},\n    )\n\n    # make the layout\n    layout = QVBoxLayout()\n    layout.addWidget(self.bounding_box_widget.native)\n    self.setLayout(layout)\n\n    # set the style\n    self.setMaximumWidth(350)\n    self.setStyleSheet(GROUP_BOX_STYLE)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.ViewBoundingBoxControls.update_bounding_box","title":"update_bounding_box","text":"<pre><code>update_bounding_box(minimum: tuple[float, float, float], maximum: tuple[float, float, float]) -&gt; BoundingBoxViewRequest\n</code></pre> <p>Update the bounding box controls with new minimum and maximum values.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def update_bounding_box(\n    self, minimum: tuple[float, float, float], maximum: tuple[float, float, float]\n) -&gt; BoundingBoxViewRequest:\n    \"\"\"Update the bounding box controls with new minimum and maximum values.\"\"\"\n    # This method can be extended to update the bounding box controls\n    # based on the provided minimum and maximum coordinates.\n    # For now, it is a placeholder.\n    return BoundingBoxViewRequest(\n        minimum=np.asarray(minimum), maximum=np.asarray(maximum)\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/qt/auxiliary_views/","title":"auxiliary_views","text":""},{"location":"reference/skeleplex/app/qt/auxiliary_views/#skeleplex.app.qt.auxiliary_views","title":"skeleplex.app.qt.auxiliary_views","text":"<p>Dock widget to hold additional views of the data.</p> <p>Classes:</p> <ul> <li> <code>AuxiliaryViews</code>           \u2013            <p>A dock widget for the auxiliary views.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/auxiliary_views/#skeleplex.app.qt.auxiliary_views.AuxiliaryViews","title":"AuxiliaryViews","text":"<pre><code>AuxiliaryViews(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QDockWidget</code></p> <p>A dock widget for the auxiliary views.</p> <p>This will hold things like a view of slices along a spline.</p> Source code in <code>skeleplex/app/qt/auxiliary_views.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n    self.setStyleSheet(DOCK_WIDGET_STYLE)\n\n    self.label = QLabel(\"I'm the Auxiliary Views\")\n    self.label.setMinimumWidth(self.MINIMUM_WIDTH)\n\n    self.setWidget(self.label)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/","title":"flat_group_box","text":""},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box","title":"skeleplex.app.qt.flat_group_box","text":"<p>A flat-styled group box widget.</p> <p>Classes:</p> <ul> <li> <code>FlatHFrame</code>           \u2013            <p>A flat-styled frame widget with a horizontal layout.</p> </li> <li> <code>FlatHGroupBox</code>           \u2013            <p>A flat-styled group box widget with a horizontal layout.</p> </li> <li> <code>FlatVFrame</code>           \u2013            <p>A flat-styled frame widget with a vertical layout.</p> </li> <li> <code>FlatVGroupBox</code>           \u2013            <p>A flat-styled group box widget with a vertical layout.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHFrame","title":"FlatHFrame","text":"<pre><code>FlatHFrame(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QFrame</code></p> <p>A flat-styled frame widget with a horizontal layout.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the frame.</p> </li> </ul> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n\n    # set the styling\n    self.setStyleSheet(FLAT_FRAME_STYLE)\n\n    self.setLayout(QHBoxLayout())\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHFrame(parent)","title":"<code>parent</code>","text":"(<code>QWidget | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget. The default is None.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHFrame.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the frame.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the frame.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.layout().addWidget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHFrame.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox","title":"FlatHGroupBox","text":"<pre><code>FlatHGroupBox(title: str = '', accent_color: str = '#b7e2d8', background_color: str = '#f3f3f3', collapsible: bool = False, parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>A flat-styled group box widget with a horizontal layout.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def __init__(\n    self,\n    title: str = \"\",\n    accent_color: str = \"#b7e2d8\",\n    background_color: str = \"#f3f3f3\",\n    collapsible: bool = False,\n    parent: QWidget | None = None,\n):\n    super().__init__(parent=parent)\n\n    # store the collapsible property\n    self.collapsible = collapsible\n\n    # set the background color\n    self.setStyleSheet(f\"background-color: {background_color};\")\n\n    self.title_widget = QLabel(title, parent=self)\n    self.title_widget.setStyleSheet(\n        FLAT_TITLE_STYLE.format(accent_color=accent_color)\n    )\n\n    # add an callback to toggle the collapsed state when\n    # the title is clicked.\n    self.title_widget.mousePressEvent = self._toggle_collapsed\n\n    self.frame = FlatHFrame(parent=self)\n\n    layout = QVBoxLayout()\n    layout.setSpacing(0)\n    layout.setContentsMargins(0, 0, 0, 0)\n\n    layout.addWidget(self.title_widget)\n    layout.addWidget(self.frame)\n    layout.addStretch()\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox(title)","title":"<code>title</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the group box. The default is \"\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox(accent_color)","title":"<code>accent_color</code>","text":"(<code>str</code>, default:                   <code>'#b7e2d8'</code> )           \u2013            <p>The accent color for the group box. This is used for the title bar and other accents. Color should be a hex string. The default is \"#b7e2d8\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox(background_color)","title":"<code>background_color</code>","text":"(<code>str</code>, default:                   <code>'#f3f3f3'</code> )           \u2013            <p>The background color for the group box. Color should be a hex string. The default is \"#f3f3f3\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox(parent)","title":"<code>parent</code>","text":"(<code>QWidget | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget. The default is None.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVFrame","title":"FlatVFrame","text":"<pre><code>FlatVFrame(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QFrame</code></p> <p>A flat-styled frame widget with a vertical layout.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the frame.</p> </li> </ul> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n\n    # set the styling\n    self.setStyleSheet(FLAT_FRAME_STYLE)\n\n    self.setLayout(QVBoxLayout())\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVFrame(parent)","title":"<code>parent</code>","text":"(<code>QWidget | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget. The default is None.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVFrame.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the frame.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the frame.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.layout().addWidget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVFrame.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox","title":"FlatVGroupBox","text":"<pre><code>FlatVGroupBox(title: str = '', accent_color: str = '#b7e2d8', background_color: str = '#f3f3f3', collapsible: bool = False, parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>A flat-styled group box widget with a vertical layout.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def __init__(\n    self,\n    title: str = \"\",\n    accent_color: str = \"#b7e2d8\",\n    background_color: str = \"#f3f3f3\",\n    collapsible: bool = False,\n    parent: QWidget | None = None,\n):\n    super().__init__(parent=parent)\n\n    # store the collapsible property\n    self.collapsible = collapsible\n\n    # set the background color\n    self.setStyleSheet(f\"background-color: {background_color};\")\n\n    self.title_widget = QLabel(title, parent=self)\n    self.title_widget.setStyleSheet(\n        FLAT_TITLE_STYLE.format(accent_color=accent_color)\n    )\n\n    # add an callback to toggle the collapsed state when\n    # the title is clicked.\n    self.title_widget.mousePressEvent = self._toggle_collapsed\n\n    self.frame = FlatHFrame(parent=self)\n\n    layout = QVBoxLayout()\n    layout.setSpacing(0)\n    layout.setContentsMargins(0, 0, 0, 0)\n\n    layout.addWidget(self.title_widget)\n    layout.addWidget(self.frame)\n    layout.addStretch()\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox(title)","title":"<code>title</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the group box. The default is \"\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox(accent_color)","title":"<code>accent_color</code>","text":"(<code>str</code>, default:                   <code>'#b7e2d8'</code> )           \u2013            <p>The accent color for the group box. This is used for the title bar and other accents. Color should be a hex string. The default is \"#b7e2d8\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox(background_color)","title":"<code>background_color</code>","text":"(<code>str</code>, default:                   <code>'#f3f3f3'</code> )           \u2013            <p>The background color for the group box. Color should be a hex string. The default is \"#f3f3f3\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox(parent)","title":"<code>parent</code>","text":"(<code>QWidget | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget. The default is None.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/main_viewer/","title":"main_viewer","text":""},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer","title":"skeleplex.app.qt.main_viewer","text":"<p>Widgets for the main viewer.</p> <p>Classes:</p> <ul> <li> <code>ImageControls</code>           \u2013            <p>Control UI for the skeleton.</p> </li> <li> <code>MainViewerControls</code>           \u2013            <p>A widget for the main viewer controls.</p> </li> <li> <code>MainViewerFrame</code>           \u2013            <p>A frame for the main viewer canvas.</p> </li> <li> <code>MainViewerWidget</code>           \u2013            <p>A widget for the main viewer.</p> </li> <li> <code>SkeletonControls</code>           \u2013            <p>Control UI for the skeleton.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.ImageControls","title":"ImageControls","text":"<pre><code>ImageControls(parent: QWidget)\n</code></pre> <p>               Bases: <code>FlatVGroupBox</code></p> <p>Control UI for the skeleton.</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, parent: QWidget):\n    super().__init__(\n        title=\"Image Appearance\", accent_color=\"#92a8d7\", parent=parent\n    )\n\n    self.add_widget(QLabel(\"test\"))\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.ImageControls.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.ImageControls.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerControls","title":"MainViewerControls","text":"<pre><code>MainViewerControls(parent: QWidget)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>A widget for the main viewer controls.</p> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, parent: QWidget):\n    super().__init__(parent=parent)\n    self.skeleton_controls = SkeletonControls(parent=self)\n    self.image_controls = ImageControls(parent=self)\n\n    # set the maximum height\n    self.setMaximumHeight(100)\n\n    # layout\n    layout = QHBoxLayout()\n    layout.setContentsMargins(0, 0, 0, 0)\n    layout.addWidget(self.image_controls)\n    layout.addWidget(self.skeleton_controls)\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerFrame","title":"MainViewerFrame","text":"<pre><code>MainViewerFrame(canvas_widget: QWidget, parent: QWidget)\n</code></pre> <p>               Bases: <code>QFrame</code></p> <p>A frame for the main viewer canvas.</p> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, canvas_widget: QWidget, parent: QWidget):\n    super().__init__(parent=parent)\n\n    self.setStyleSheet(\"border: 1px solid black;\")\n\n    # set the minimum height\n    self.setMinimumHeight(self.MINIMUM_HEIGHT)\n\n    layout = QVBoxLayout()\n    layout.setContentsMargins(0, 0, 0, 0)\n    layout.addWidget(canvas_widget)\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerWidget","title":"MainViewerWidget","text":"<pre><code>MainViewerWidget(canvas_widget: QWidget, parent: QWidget)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>A widget for the main viewer.</p> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, canvas_widget: QWidget, parent: QWidget):\n    super().__init__(parent=parent)\n    self.main_viewer_frame = MainViewerFrame(\n        canvas_widget=canvas_widget, parent=self\n    )\n    self.main_viewer_controls = MainViewerControls(parent=self)\n\n    layout = QVBoxLayout()\n    layout.setContentsMargins(10, 5, 10, 0)\n    layout.addWidget(self.main_viewer_frame)\n    layout.addWidget(self.main_viewer_controls)\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.SkeletonControls","title":"SkeletonControls","text":"<pre><code>SkeletonControls(parent: QWidget)\n</code></pre> <p>               Bases: <code>FlatVGroupBox</code></p> <p>Control UI for the skeleton.</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, parent: QWidget):\n    super().__init__(\n        title=\"Skeleton Appearance\", accent_color=\"#92a8d7\", parent=parent\n    )\n\n    self.add_widget(QLabel(\"test\"))\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.SkeletonControls.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.SkeletonControls.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/styles/","title":"styles","text":""},{"location":"reference/skeleplex/app/qt/styles/#skeleplex.app.qt.styles","title":"skeleplex.app.qt.styles","text":"<p>QSS styles for the application.</p>"},{"location":"reference/skeleplex/app/qt/window/","title":"window","text":""},{"location":"reference/skeleplex/app/qt/window/#skeleplex.app.qt.window","title":"skeleplex.app.qt.window","text":"<p>Qt implementation of the main window for the application.</p> <p>Classes:</p> <ul> <li> <code>MainWindow</code>           \u2013            <p>Qt + app-model implementation of the main window for the application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/window/#skeleplex.app.qt.window.MainWindow","title":"MainWindow","text":"<pre><code>MainWindow(app: Application)\n</code></pre> <p>               Bases: <code>QModelMainWindow</code></p> <p>Qt + app-model implementation of the main window for the application.</p> <p>Methods:</p> <ul> <li> <code>add_auxiliary_widget</code>             \u2013              <p>Add a widget to the auxiliary views dock.</p> </li> </ul> Source code in <code>skeleplex/app/qt/window.py</code> <pre><code>def __init__(self, app: Application):\n    super().__init__(app)\n\n    # set the background color\n    self.setStyleSheet(MAIN_WINDOW_STYLE)\n\n    # self.tool_bar = self.addModelToolBar(MenuId.FILE, exclude={CommandId.OPEN})\n    # self.tool_bar.setStyleSheet(\"background: white;\")\n\n    # set the central widget\n    self.setCentralWidget(QLabel(\"I'm the Central Widget\"))\n\n    # set the minimum window size - app will launch with this size.\n    self.setMinimumSize(MIN_WINDOW_WIDTH, MIN_WINDOW_HEIGHT)\n\n    # Create the app controls as a dock widget (left)\n    self._create_app_controls()\n\n    # create the auxiliary views as a dock widget (right)\n    self._create_auxiliary_views()\n\n    # create the status bar at the bottom of the window\n    self._create_status_bar()\n</code></pre>"},{"location":"reference/skeleplex/app/qt/window/#skeleplex.app.qt.window.MainWindow.add_auxiliary_widget","title":"add_auxiliary_widget","text":"<pre><code>add_auxiliary_widget(widget: QWidget, name: str = '')\n</code></pre> <p>Add a widget to the auxiliary views dock.</p> Source code in <code>skeleplex/app/qt/window.py</code> <pre><code>def add_auxiliary_widget(self, widget: QWidget, name: str = \"\"):\n    \"\"\"Add a widget to the auxiliary views dock.\"\"\"\n    dock_widget = QDockWidget(name)\n    dock_widget.setWidget(widget)\n    self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, dock_widget)\n</code></pre>"},{"location":"reference/skeleplex/data/","title":"data","text":""},{"location":"reference/skeleplex/data/#skeleplex.data","title":"skeleplex.data","text":"<p>Example data.</p> <p>Modules:</p> <ul> <li> <code>bifurcating_tree</code>           \u2013            <p>Creating biforcating trees as example data.</p> </li> <li> <code>skeleton_image</code>           \u2013            <p>Example skeleton images.</p> </li> <li> <code>skeletons</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>big_t</code>             \u2013              <p>Make an image with a big T skeleton.</p> </li> <li> <code>simple_t</code>             \u2013              <p>Make an image with a simple T skeleton.</p> </li> </ul>"},{"location":"reference/skeleplex/data/#skeleplex.data.big_t","title":"big_t","text":"<pre><code>big_t() -&gt; ndarray\n</code></pre> <p>Make an image with a big T skeleton.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A binary image with a big T skeleton. The image has shape (100, 100, 100)</p> </li> </ul> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def big_t() -&gt; np.ndarray:\n    \"\"\"Make an image with a big T skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        A binary image with a big T skeleton.\n        The image has shape (100, 100, 100)\n    \"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(50, 25), (50, 50)],\n        [(50, 50), (50, 75)],\n        [(50, 50), (75, 50)],\n    ]\n\n    # draw the image\n    image = np.zeros((100, 100, 100), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[50, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/#skeleplex.data.simple_t","title":"simple_t","text":"<pre><code>simple_t() -&gt; ndarray\n</code></pre> <p>Make an image with a simple T skeleton.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A binary image with a simple T skeleton. The image has shape (20, 20, 20)</p> </li> </ul> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def simple_t() -&gt; np.ndarray:\n    \"\"\"Make an image with a simple T skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        A binary image with a simple T skeleton.\n        The image has shape (20, 20, 20)\n    \"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(10, 5), (10, 10)],\n        [(10, 10), (10, 15)],\n        [(10, 10), (15, 10)],\n    ]\n\n    # draw the image\n    image = np.zeros((20, 20, 20), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[10, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/bifurcating_tree/","title":"bifurcating_tree","text":""},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree","title":"skeleplex.data.bifurcating_tree","text":"<p>Creating biforcating trees as example data.</p> <p>Functions:</p> <ul> <li> <code>apply_dilation_3d</code>             \u2013              <p>Apply morphological dilation to thicken the tree structure in 3D.</p> </li> <li> <code>draw_branch_2d</code>             \u2013              <p>Adds branches to a bifurcating tree in a single 2D layer.</p> </li> <li> <code>generate_tree_3d</code>             \u2013              <p>Generate a 3D bifurcating tree in a specified z-layer of a 3D image.</p> </li> </ul>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.apply_dilation_3d","title":"apply_dilation_3d","text":"<pre><code>apply_dilation_3d(image, dilation_radius=3)\n</code></pre> <p>Apply morphological dilation to thicken the tree structure in 3D.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A dilated version of the input tree image.</p> </li> </ul> Source code in <code>skeleplex/data/bifurcating_tree.py</code> <pre><code>def apply_dilation_3d(image, dilation_radius=3):\n    \"\"\"\n    Apply morphological dilation to thicken the tree structure in 3D.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        A binary 3D image containing the tree structure.\n    dilation_radius : int, optional\n        The radius of the structuring element for dilation, by default 3.\n\n    Returns\n    -------\n    np.ndarray\n        A dilated version of the input tree image.\n    \"\"\"\n    structuring_element = ball(dilation_radius)\n    dilated_image = binary_dilation(image, structure=structuring_element)\n\n    return dilated_image\n</code></pre>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.apply_dilation_3d(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>A binary 3D image containing the tree structure.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.apply_dilation_3d(dilation_radius)","title":"<code>dilation_radius</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The radius of the structuring element for dilation, by default 3.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d","title":"draw_branch_2d","text":"<pre><code>draw_branch_2d(image, start, length, angle, level, max_levels, z_layer=10, left_angle=30, right_angle=30, length_ratio=0.7)\n</code></pre> <p>Adds branches to a bifurcating tree in a single 2D layer.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Modifies the input image in place.</p> </li> </ul> Source code in <code>skeleplex/data/bifurcating_tree.py</code> <pre><code>def draw_branch_2d(\n    image,\n    start,\n    length,\n    angle,\n    level,\n    max_levels,\n    z_layer=10,\n    left_angle=30,\n    right_angle=30,\n    length_ratio=0.7,\n):\n    \"\"\"\n    Adds branches to a bifurcating tree in a single 2D layer.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The 3D binary image where the tree is drawn.\n    start : tuple[int, int]\n        The (y, x) starting position of the branch.\n    length : int\n        The length of the current branch.\n    angle : float\n        The angle (in degrees) at which the branch grows.\n    level : int\n        The current recursion depth (bifurcation level).\n    max_levels : int\n        The maximum number of bifurcation levels.\n    z_layer : int, optional\n        The z-plane in which the tree is drawn, by default 10.\n    left_angle : float, optional\n        The angle offset for left branches, by default 30 degrees.\n    right_angle : float, optional\n        The angle offset for right branches, by default 30 degrees.\n    length_ratio : float, optional\n        The ratio by which branch length decreases in each bifurcation, by default 0.7.\n\n    Returns\n    -------\n    None\n        Modifies the input image in place.\n    \"\"\"\n    if level &gt; max_levels or length &lt;= 0:\n        return\n\n    # Calculate the end point of the branch\n    y_end = start[0] + int(length * np.cos(np.radians(angle)))\n    x_end = start[1] + int(length * np.sin(np.radians(angle)))\n\n    # Clip endpoints to stay within the image bounds\n    y_end = np.clip(y_end, 0, image.shape[1] - 1)\n    x_end = np.clip(x_end, 0, image.shape[2] - 1)\n\n    # Draw the branch in the specific z-layer\n    rr, cc = line(start[0], start[1], y_end, x_end)\n    image[z_layer, rr, cc] = 1\n\n    # New starting point for daughter branches\n    new_start = (y_end, x_end)\n\n    # Add left and right daughter branches\n    draw_branch_2d(\n        image,\n        new_start,\n        int(length * length_ratio),\n        angle - left_angle,\n        level + 1,\n        max_levels,\n        z_layer,\n        left_angle,\n        right_angle,\n        length_ratio,\n    )  # Left branch\n\n    draw_branch_2d(\n        image,\n        new_start,\n        int(length * length_ratio),\n        angle + right_angle,\n        level + 1,\n        max_levels,\n        z_layer,\n        left_angle,\n        right_angle,\n        length_ratio,\n    )  # Right branch\n</code></pre>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The 3D binary image where the tree is drawn.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(start)","title":"<code>start</code>","text":"(<code>tuple[int, int]</code>)           \u2013            <p>The (y, x) starting position of the branch.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(length)","title":"<code>length</code>","text":"(<code>int</code>)           \u2013            <p>The length of the current branch.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(angle)","title":"<code>angle</code>","text":"(<code>float</code>)           \u2013            <p>The angle (in degrees) at which the branch grows.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(level)","title":"<code>level</code>","text":"(<code>int</code>)           \u2013            <p>The current recursion depth (bifurcation level).</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(max_levels)","title":"<code>max_levels</code>","text":"(<code>int</code>)           \u2013            <p>The maximum number of bifurcation levels.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(z_layer)","title":"<code>z_layer</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The z-plane in which the tree is drawn, by default 10.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(left_angle)","title":"<code>left_angle</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>The angle offset for left branches, by default 30 degrees.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(right_angle)","title":"<code>right_angle</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>The angle offset for right branches, by default 30 degrees.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(length_ratio)","title":"<code>length_ratio</code>","text":"(<code>float</code>, default:                   <code>0.7</code> )           \u2013            <p>The ratio by which branch length decreases in each bifurcation, by default 0.7.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d","title":"generate_tree_3d","text":"<pre><code>generate_tree_3d(shape=(100, 100, 100), nodes=1, branch_length=20, z_layer=10, left_angle=30, right_angle=30, length_ratio=0.7)\n</code></pre> <p>Generate a 3D bifurcating tree in a specified z-layer of a 3D image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A 3D binary image with the generated tree structure.</p> </li> </ul> Source code in <code>skeleplex/data/bifurcating_tree.py</code> <pre><code>def generate_tree_3d(\n    shape=(100, 100, 100),\n    nodes=1,\n    branch_length=20,\n    z_layer=10,\n    left_angle=30,\n    right_angle=30,\n    length_ratio=0.7,\n):\n    \"\"\"\n    Generate a 3D bifurcating tree in a specified z-layer of a 3D image.\n\n    Parameters\n    ----------\n    shape : tuple[int, int, int], optional\n        The dimensions of the 3D image, by default (100, 100, 100).\n    nodes : int, optional\n        The number of bifurcation levels, by default 1.\n    branch_length : int, optional\n        The length of the initial trunk, by default 20.\n    z_layer : int, optional\n        The specific z-plane where the tree is generated, by default 10.\n    left_angle : float, optional\n        The angle offset for left branches, by default 30 degrees.\n    right_angle : float, optional\n        The angle offset for right branches, by default 30 degrees.\n    length_ratio : float, optional\n        The ratio by which branch length decreases per bifurcation, by default 0.7.\n\n    Returns\n    -------\n    np.ndarray\n        A 3D binary image with the generated tree structure.\n    \"\"\"\n    # Create an empty black 3D image\n    image = np.zeros(shape, dtype=bool)\n\n    # Starting point of the tree (top center of the chosen z-layer)\n    # with a border of 20 pixels\n    start = (20, shape[1] // 2)\n\n    # Add the main trunk growing downward in the specified z-layer\n    draw_branch_2d(\n        image,\n        start,\n        branch_length,\n        angle=0,\n        level=0,\n        max_levels=nodes,\n        z_layer=z_layer,\n        left_angle=left_angle,\n        right_angle=right_angle,\n        length_ratio=length_ratio,\n    )\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(100, 100, 100)</code> )           \u2013            <p>The dimensions of the 3D image, by default (100, 100, 100).</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(nodes)","title":"<code>nodes</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of bifurcation levels, by default 1.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(branch_length)","title":"<code>branch_length</code>","text":"(<code>int</code>, default:                   <code>20</code> )           \u2013            <p>The length of the initial trunk, by default 20.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(z_layer)","title":"<code>z_layer</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The specific z-plane where the tree is generated, by default 10.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(left_angle)","title":"<code>left_angle</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>The angle offset for left branches, by default 30 degrees.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(right_angle)","title":"<code>right_angle</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>The angle offset for right branches, by default 30 degrees.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(length_ratio)","title":"<code>length_ratio</code>","text":"(<code>float</code>, default:                   <code>0.7</code> )           \u2013            <p>The ratio by which branch length decreases per bifurcation, by default 0.7.</p>"},{"location":"reference/skeleplex/data/skeleton_image/","title":"skeleton_image","text":""},{"location":"reference/skeleplex/data/skeleton_image/#skeleplex.data.skeleton_image","title":"skeleplex.data.skeleton_image","text":"<p>Example skeleton images.</p> <p>Functions:</p> <ul> <li> <code>big_t</code>             \u2013              <p>Make an image with a big T skeleton.</p> </li> <li> <code>simple_bifurcating_branches</code>             \u2013              <p>Create a skeleton image with a simple bifurcating tree.</p> </li> <li> <code>simple_t</code>             \u2013              <p>Make an image with a simple T skeleton.</p> </li> </ul>"},{"location":"reference/skeleplex/data/skeleton_image/#skeleplex.data.skeleton_image.big_t","title":"big_t","text":"<pre><code>big_t() -&gt; ndarray\n</code></pre> <p>Make an image with a big T skeleton.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A binary image with a big T skeleton. The image has shape (100, 100, 100)</p> </li> </ul> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def big_t() -&gt; np.ndarray:\n    \"\"\"Make an image with a big T skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        A binary image with a big T skeleton.\n        The image has shape (100, 100, 100)\n    \"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(50, 25), (50, 50)],\n        [(50, 50), (50, 75)],\n        [(50, 50), (75, 50)],\n    ]\n\n    # draw the image\n    image = np.zeros((100, 100, 100), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[50, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/skeleton_image/#skeleplex.data.skeleton_image.simple_bifurcating_branches","title":"simple_bifurcating_branches","text":"<pre><code>simple_bifurcating_branches() -&gt; ndarray\n</code></pre> <p>Create a skeleton image with a simple bifurcating tree.</p> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def simple_bifurcating_branches() -&gt; np.ndarray:\n    \"\"\"Create a skeleton image with a simple bifurcating tree.\"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(20, 100), (40, 100)],\n        [(40, 100), (60, 80)],\n        [(40, 100), (60, 120)],\n        [(60, 80), (75, 65)],\n        [(60, 80), (75, 95)],\n        [(60, 120), (75, 105)],\n        [(60, 120), (75, 135)],\n    ]\n\n    # draw the image\n    image = np.zeros((200, 200, 200), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[100, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/skeleton_image/#skeleplex.data.skeleton_image.simple_t","title":"simple_t","text":"<pre><code>simple_t() -&gt; ndarray\n</code></pre> <p>Make an image with a simple T skeleton.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A binary image with a simple T skeleton. The image has shape (20, 20, 20)</p> </li> </ul> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def simple_t() -&gt; np.ndarray:\n    \"\"\"Make an image with a simple T skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        A binary image with a simple T skeleton.\n        The image has shape (20, 20, 20)\n    \"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(10, 5), (10, 10)],\n        [(10, 10), (10, 15)],\n        [(10, 10), (15, 10)],\n    ]\n\n    # draw the image\n    image = np.zeros((20, 20, 20), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[10, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/skeletons/","title":"skeletons","text":""},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons","title":"skeleplex.data.skeletons","text":"<p>Functions:</p> <ul> <li> <code>generate_toy_skeleton_graph_symmetric_branch_angle</code>             \u2013              <p>Generate a toy skeleton graph with a symmetric branch angle.</p> </li> </ul>"},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons.generate_toy_skeleton_graph_symmetric_branch_angle","title":"generate_toy_skeleton_graph_symmetric_branch_angle","text":"<pre><code>generate_toy_skeleton_graph_symmetric_branch_angle(num_nodes: int = 19, angle: int = 72, edge_length: float = 20) -&gt; SkeletonGraph\n</code></pre> <p>Generate a toy skeleton graph with a symmetric branch angle.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/skeletons.py</code> <pre><code>def generate_toy_skeleton_graph_symmetric_branch_angle(\n    num_nodes: int = 19, angle: int = 72, edge_length: float = 20\n) -&gt; SkeletonGraph:\n    \"\"\"Generate a toy skeleton graph with a symmetric branch angle.\n\n    Parameters\n    ----------\n    num_nodes : int\n        The number of nodes in the graph.\n    angle : int\n        The angle between branches in degrees.\n    edge_length : float\n        The length of each edge in the graph.\n\n    \"\"\"\n    # Create a directed graph\n    graph = nx.DiGraph()\n\n    # Convert angle to radians and divide by 2 for symmetric branching\n    angle_rad = np.radians(angle / 2)\n\n    # Initialize node positions dictionary with the root node at the origin\n    node_pos_dic = {0: np.array([0, 0, 0])}\n    parent_nodes = [0]  # Start with the root node\n\n    # Add trachea node and edge\n    trachea_pos = np.array([-edge_length, 0, 0])\n    node_pos_dic[-1] = trachea_pos\n    graph.add_node(-1, node_coordinate=trachea_pos)\n    graph.add_edge(\n        -1,\n        0,\n        **{\n            EDGE_COORDINATES_KEY: np.linspace(\n                trachea_pos, np.array([0, 0, 0]), 5 + edge_length\n            )\n        },\n    )\n\n    # Initialize the first two branches\n    m = edge_length * np.cos(angle_rad)\n    n = edge_length * np.sin(angle_rad)\n    new_pos = node_pos_dic[0] + np.array([m, n, 0])\n    node_pos_dic[1] = new_pos\n    edge_coordinates = np.linspace(node_pos_dic[0], new_pos, 5 + edge_length)\n    graph.add_node(1)\n    graph.add_edge(0, 1, **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": \"left\"})\n\n    m = edge_length * np.cos(-angle_rad)\n    n = edge_length * np.sin(-angle_rad)\n    new_pos = node_pos_dic[0] + np.array([m, n, 0])\n    node_pos_dic[2] = new_pos\n    edge_coordinates = np.linspace(node_pos_dic[0], new_pos, 5 + edge_length)\n    graph.add_node(2)\n    graph.add_edge(0, 2, **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": \"right\"})\n\n    parent_nodes = [1, 2]  # Update parent nodes to the first two branches\n    i = 3  # Start adding new nodes from index 3\n\n    while i &lt; num_nodes:\n        new_parents = []\n        for parent_node in parent_nodes:\n            if i &lt; num_nodes:\n                # Add the first child node\n                angle_rad = np.radians(angle / 2)\n\n                # Get the path to the root node\n                # count the number of left vs right edges\n                path = nx.shortest_path(graph, 0, parent_node)\n                edges = [(path[j], path[j + 1]) for j in range(len(path) - 1)]\n                sides = [graph.edges[edge][\"side\"] for edge in edges]\n                left_edges = sides.count(\"left\")\n                right_edges = sides.count(\"right\")\n                num_rotations = left_edges - right_edges\n\n                # Adjust angle based on the number of rotations\n                angle_rad *= num_rotations + 1\n\n                m = edge_length * np.cos(angle_rad)\n                n = edge_length * np.sin(angle_rad)\n                side = \"left\"\n                new_pos = node_pos_dic[parent_node] + np.array([m, n, 0])\n\n                node_pos_dic[i] = new_pos\n                edge_coordinates = np.linspace(\n                    node_pos_dic[parent_node], new_pos, 5 + edge_length\n                )\n                graph.add_node(i)\n                graph.add_edge(\n                    parent_node,\n                    i,\n                    **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": side},\n                )\n                new_parents.append(i)\n                i += 1\n\n            if i &lt; num_nodes:\n                # Add the second child node and rotate in the opposite direction\n                angle_rad = np.radians(angle) / 2\n\n                path = nx.shortest_path(graph, 0, parent_node)\n                edges = [(path[j], path[j + 1]) for j in range(len(path) - 1)]\n                sides = [graph.edges[edge][\"side\"] for edge in edges]\n                left_edges = sides.count(\"left\")\n                right_edges = sides.count(\"right\")\n                num_rotations = left_edges - right_edges\n\n                angle_rad *= num_rotations - 1\n\n                m = edge_length * np.cos(angle_rad)\n                n = edge_length * np.sin(angle_rad)\n                side = \"right\"\n                new_pos = node_pos_dic[parent_node] + np.array([m, n, 0])\n                node_pos_dic[i] = new_pos\n                edge_coordinates = np.linspace(\n                    node_pos_dic[parent_node], new_pos, 5 + edge_length\n                )\n                graph.add_node(i)\n                graph.add_edge(\n                    parent_node,\n                    i,\n                    **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": side},\n                )\n                new_parents.append(i)\n                i += 1\n\n        parent_nodes = new_parents  # Update parent nodes for the next iteration\n\n    # Set node attributes for the graph\n    nx.set_node_attributes(graph, node_pos_dic, NODE_COORDINATE_KEY)\n\n    # Create a SkeletonGraph from the graph\n    skeleton_graph = SkeletonGraph.from_graph(\n        graph, EDGE_COORDINATES_KEY, NODE_COORDINATE_KEY\n    )\n    return skeleton_graph\n</code></pre>"},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons.generate_toy_skeleton_graph_symmetric_branch_angle(num_nodes)","title":"<code>num_nodes</code>","text":"(<code>int</code>, default:                   <code>19</code> )           \u2013            <p>The number of nodes in the graph.</p>"},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons.generate_toy_skeleton_graph_symmetric_branch_angle(angle)","title":"<code>angle</code>","text":"(<code>int</code>, default:                   <code>72</code> )           \u2013            <p>The angle between branches in degrees.</p>"},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons.generate_toy_skeleton_graph_symmetric_branch_angle(edge_length)","title":"<code>edge_length</code>","text":"(<code>float</code>, default:                   <code>20</code> )           \u2013            <p>The length of each edge in the graph.</p>"},{"location":"reference/skeleplex/graph/","title":"graph","text":""},{"location":"reference/skeleplex/graph/#skeleplex.graph","title":"skeleplex.graph","text":"<p>Tools to create a graph of a skeleton.</p> <p>Modules:</p> <ul> <li> <code>constants</code>           \u2013            <p>Constants used for interacting with the graph objects.</p> </li> <li> <code>image_to_graph</code>           \u2013            <p>Utilities to convert a skeleton image to a graph.</p> </li> <li> <code>modify_graph</code>           \u2013            </li> <li> <code>sample</code>           \u2013            <p>Functions for sampling images using the SkeletonGraph.</p> </li> <li> <code>skeleton_graph</code>           \u2013            <p>Data class for a skeleton graph.</p> </li> <li> <code>spline</code>           \u2013            <p>Utilities for fitting and working with splines.</p> </li> <li> <code>utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>SkeletonGraph</code>           \u2013            <p>Data class for a skeleton graph.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph","title":"SkeletonGraph","text":"<pre><code>SkeletonGraph(graph: Graph, origin: int | None = None, image_path: str | None = None, image_key: str | None = None, voxel_size_um: float | None = None)\n</code></pre> <p>Data class for a skeleton graph.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>compute_branch_lengths</code>             \u2013              <p>Return a dictionary of edge lengths.</p> </li> <li> <code>from_graph</code>             \u2013              <p>Return a SkeletonGraph from a networkx graph.</p> </li> <li> <code>from_json_file</code>             \u2013              <p>Return a SkeletonGraph from a JSON file.</p> </li> <li> <code>from_skeleton_image</code>             \u2013              <p>Return a SkeletonGraph from a skeleton image.</p> </li> <li> <code>orient_splines</code>             \u2013              <p>Orient the splines in the graph.</p> </li> <li> <code>sample_volume_slices_from_spline</code>             \u2013              <p>Sample volume slices from the splines in the graph.</p> </li> <li> <code>to_directed</code>             \u2013              <p>Return a directed graph from the skeleton graph.</p> </li> <li> <code>to_json_file</code>             \u2013              <p>Return a JSON representation of the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>backend</code>               (<code>str</code>)           \u2013            <p>Return the backend used to store the graph.</p> </li> <li> <code>edge_splines</code>               (<code>dict</code>)           \u2013            <p>Return a list of edge splines.</p> </li> <li> <code>edges</code>           \u2013            <p>Return a list of edges.</p> </li> <li> <code>node_coordinates</code>               (<code>dict</code>)           \u2013            <p>Return a dictionary of node coordinates.</p> </li> <li> <code>node_coordinates_array</code>               (<code>ndarray</code>)           \u2013            <p>Return a numpy array of node coordinates.</p> </li> <li> <code>nodes</code>           \u2013            <p>Return a list of nodes.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def __init__(\n    self,\n    graph: nx.Graph,\n    origin: int | None = None,\n    image_path: str | None = None,\n    image_key: str | None = None,\n    voxel_size_um: float | None = None,\n):\n    self.graph = graph\n    self.origin = origin\n    self.image_path = image_path\n    self.image_key = image_key\n    self.voxel_size_um = voxel_size_um\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The skeleton graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(origin)","title":"<code>origin</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The origin node of the graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(image_path)","title":"<code>image_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image the graph was extracted from.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(image_key)","title":"<code>image_key</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The key of the image in the image file.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(voxel_size_um)","title":"<code>voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the image in the image file. We keep the graph scaled to um for easier handling.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: str\n</code></pre> <p>Return the backend used to store the graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.edge_splines","title":"edge_splines  <code>property</code>","text":"<pre><code>edge_splines: dict\n</code></pre> <p>Return a list of edge splines.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.edges","title":"edges  <code>property</code>","text":"<pre><code>edges\n</code></pre> <p>Return a list of edges.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: dict\n</code></pre> <p>Return a dictionary of node coordinates.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.node_coordinates_array","title":"node_coordinates_array  <code>property</code>","text":"<pre><code>node_coordinates_array: ndarray\n</code></pre> <p>Return a numpy array of node coordinates.</p> <p>The array is of shape (n_nodes, n_dimensions). The order of the nodes is the same as the order of the nodes attribute.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Return a list of nodes.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.compute_branch_lengths","title":"compute_branch_lengths","text":"<pre><code>compute_branch_lengths() -&gt; dict\n</code></pre> <p>Return a dictionary of edge lengths.</p> <p>The keys of the dictionary are the edge tuples, the values are arc lengths of the fitted splines. Units will be the same as voxel scale.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def compute_branch_lengths(self) -&gt; dict:\n    \"\"\"Return a dictionary of edge lengths.\n\n    The keys of the dictionary are the edge tuples, the values are arc lengths\n    of the fitted splines. Units will be the same as voxel scale.\n    \"\"\"\n    edge_lengths = {}\n    for u, v, attr in self.graph.edges(data=True):\n        edge_lengths[(u, v)] = attr[EDGE_SPLINE_KEY].arc_length\n\n    nx.set_edge_attributes(self.graph, edge_lengths, LENGTH_KEY)\n    return edge_lengths\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph","title":"from_graph  <code>classmethod</code>","text":"<pre><code>from_graph(graph, edge_coordinate_key, node_coordinate_key) -&gt; SkeletonGraph\n</code></pre> <p>Return a SkeletonGraph from a networkx graph.</p> <p>The edges and nodes need to have an attribute with the specified keys containing the coordinates of the nodes and edges as an np.ndarray. Requires edge coordinates of length greater than 4 to successfully create a spline.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_graph(\n    cls, graph, edge_coordinate_key, node_coordinate_key\n) -&gt; \"SkeletonGraph\":\n    \"\"\"Return a SkeletonGraph from a networkx graph.\n\n    The edges and nodes need to have an attribute with the specified keys\n    containing the coordinates of the nodes and edges as an np.ndarray.\n    Requires edge coordinates of length greater than 4\n    to successfully create a spline.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        The graph to convert to a SkeletonGraph.\n    edge_coordinate_key : str\n        The key to use for the edge coordinates.\n    node_coordinate_key : str\n        The key to use for the node coordinates.\n    \"\"\"\n    graph_mod = graph.copy()\n    for _, _, attr in graph_mod.edges(data=True):\n        attr[EDGE_COORDINATES_KEY] = attr.pop(edge_coordinate_key)\n        # add spline\n        spline = B3Spline.from_points(attr[EDGE_COORDINATES_KEY])\n        attr[EDGE_SPLINE_KEY] = spline\n    for _, node_data in graph_mod.nodes(data=True):\n        node_data[NODE_COORDINATE_KEY] = node_data.pop(node_coordinate_key)\n    return cls(graph=graph_mod)\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The graph to convert to a SkeletonGraph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph(edge_coordinate_key)","title":"<code>edge_coordinate_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the edge coordinates.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph(node_coordinate_key)","title":"<code>node_coordinate_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the node coordinates.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_json_file","title":"from_json_file  <code>classmethod</code>","text":"<pre><code>from_json_file(file_path: str)\n</code></pre> <p>Return a SkeletonGraph from a JSON file.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_json_file(cls, file_path: str):\n    \"\"\"Return a SkeletonGraph from a JSON file.\"\"\"\n    with open(file_path) as file:\n        object_dict = json.load(file, object_hook=skeleton_graph_decoder)\n    graph = nx.node_link_graph(object_dict[\"graph\"], edges=\"edges\")\n    skeleton_object = cls(graph=graph)\n    # do only if keys exist\n    if \"origin\" in object_dict:\n        skeleton_object.origin = object_dict[\"origin\"]\n    if \"image_path\" in object_dict:\n        skeleton_object.image_path = object_dict[\"image_path\"]\n    if \"image_key\" in object_dict:\n        skeleton_object.image_key = object_dict[\"image_key\"]\n    if \"voxel_size_um\" in object_dict:\n        voxel_size_um = object_dict[\"voxel_size_um\"]\n        if voxel_size_um:\n            voxel_size_um = tuple(voxel_size_um)\n        skeleton_object.voxel_size_um = voxel_size_um\n\n    return skeleton_object\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_skeleton_image","title":"from_skeleton_image  <code>classmethod</code>","text":"<pre><code>from_skeleton_image(skeleton_image: ndarray, max_spline_knots: int = 10) -&gt; SkeletonGraph\n</code></pre> <p>Return a SkeletonGraph from a skeleton image.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_skeleton_image(\n    cls, skeleton_image: np.ndarray, max_spline_knots: int = 10\n) -&gt; \"SkeletonGraph\":\n    \"\"\"Return a SkeletonGraph from a skeleton image.\n\n    Parameters\n    ----------\n    skeleton_image : np.ndarray\n        The skeleton image to convert to a graph.\n    max_spline_knots : int\n        The maximum number of knots to use for the spline fit to the branch path.\n        If the number of data points in the branch is less than this number,\n        the spline will use n_data_points - 1 knots.\n        See the splinebox Spline class docs for more information.\n    \"\"\"\n    graph = image_to_graph_skan(\n        skeleton_image=skeleton_image, max_spline_knots=max_spline_knots\n    )\n    return cls(graph=graph)\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_skeleton_image(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton image to convert to a graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_skeleton_image(max_spline_knots)","title":"<code>max_spline_knots</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of knots to use for the spline fit to the branch path. If the number of data points in the branch is less than this number, the spline will use n_data_points - 1 knots. See the splinebox Spline class docs for more information.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.orient_splines","title":"orient_splines","text":"<pre><code>orient_splines() -&gt; DiGraph\n</code></pre> <p>Orient the splines in the graph.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def orient_splines(self) -&gt; nx.DiGraph:\n    \"\"\"Orient the splines in the graph.\"\"\"\n    self.graph = orient_splines(self.graph)\n    return self.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline","title":"sample_volume_slices_from_spline","text":"<pre><code>sample_volume_slices_from_spline(volume: ndarray, slice_spacing: float, slice_size: int, interpolation_order: int = 3, max_generation: int | None = None, segmentation: ndarray | None = None)\n</code></pre> <p>Sample volume slices from the splines in the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of image slices.</p> </li> <li> <code>Optional</code> (              <code>tuple(dict, dict)</code> )          \u2013            <p>A tuple of dictionaries of image and segmentation slices. Only if segmentation is not None.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def sample_volume_slices_from_spline(\n    self,\n    volume: np.ndarray,\n    slice_spacing: float,\n    slice_size: int,\n    interpolation_order: int = 3,\n    max_generation: int | None = None,\n    segmentation: np.ndarray | None = None,\n):\n    \"\"\"Sample volume slices from the splines in the graph.\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        The volume to sample slices from.\n    slice_spacing : float\n        The spacing between slices. Normalized between 0 and 1.\n    slice_size : int\n        The size of the slices in pixels.\n    interpolation_order : int\n        The order of the interpolation to use for the spline.\n        For labels use 0\n    max_generation : int\n        The maximum generation of the spline to sample.\n        If None, all levels are sampled.\n    segmentation : np.ndarray | None\n        The segmentation to sample slices from.\n        If None, only the image is sampled.\n\n    Returns\n    -------\n    dict\n        A dictionary of image slices.\n\n    Optional: tuple(dict, dict)\n        A tuple of dictionaries of image and segmentation slices.\n        Only if segmentation is not None.\n\n    \"\"\"\n    image_voxel_size_um = self.voxel_size_um\n\n    origin = self.origin\n    if not origin:\n        raise ValueError(\"No origin node provided. Please set origin.\")\n\n    if not image_voxel_size_um:\n        logger.warning(\"No voxel size provided. Assuming pixel size is 1 \u00b5m.\")\n        image_voxel_size_um = (1, 1, 1)\n\n    graph = self.graph.copy()\n    generation_dict = nx.get_edge_attributes(graph, GENERATION_KEY)\n    spline_dict = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n\n    # Scale the pixel size to the image voxel size\n    pixel_size = 1 / image_voxel_size_um[0]\n\n    image_slice_dict = {}\n    segmentation_slice_dict = {}\n\n    for u, v in nx.breadth_first_search.bfs_edges(graph, source=origin):\n        logger.info(f\"Sampling slices from edge ({u}, {v})\")\n\n        if max_generation and (generation_dict[(u, v)] &gt;= max_generation):\n            break\n        spline = spline_dict[(u, v)]\n        positions = np.linspace(0.1, 0.9, np.ceil(1 / slice_spacing).astype(int))\n        image_slice = spline.sample_volume_2d(\n            volume,\n            positions,\n            grid_shape=(slice_size, slice_size),\n            grid_spacing=(pixel_size, pixel_size),\n            sample_interpolation_order=interpolation_order,\n            image_voxel_size_um=image_voxel_size_um,\n        )\n        image_slice_dict[(u, v)] = image_slice\n\n        if segmentation is not None:\n            segmentation_slice = spline.sample_volume_2d(\n                segmentation,\n                positions,\n                grid_shape=(slice_size, slice_size),\n                grid_spacing=(pixel_size, pixel_size),\n                sample_interpolation_order=0,\n                image_voxel_size_um=image_voxel_size_um,\n            )\n            segmentation_slice_dict[(u, v)] = segmentation_slice\n\n    if segmentation is not None:\n        return image_slice_dict, segmentation_slice_dict\n    else:\n        return image_slice_dict\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The volume to sample slices from.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(slice_spacing)","title":"<code>slice_spacing</code>","text":"(<code>float</code>)           \u2013            <p>The spacing between slices. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(slice_size)","title":"<code>slice_size</code>","text":"(<code>int</code>)           \u2013            <p>The size of the slices in pixels.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The order of the interpolation to use for the spline. For labels use 0</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(max_generation)","title":"<code>max_generation</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum generation of the spline to sample. If None, all levels are sampled.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(segmentation)","title":"<code>segmentation</code>","text":"(<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>The segmentation to sample slices from. If None, only the image is sampled.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.to_directed","title":"to_directed","text":"<pre><code>to_directed(origin: int) -&gt; DiGraph\n</code></pre> <p>Return a directed graph from the skeleton graph.</p> <p>The directed graph has the same nodes and edges as the skeleton graph. Stores the origin node as an attribute.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def to_directed(self, origin: int) -&gt; nx.DiGraph:\n    \"\"\"Return a directed graph from the skeleton graph.\n\n    The directed graph has the same nodes and edges as the skeleton graph.\n    Stores the origin node as an attribute.\n\n    Parameters\n    ----------\n    origin : int\n        The node to use as the origin node for the directed graph.\n        The origin node will have no incoming edges.\n    \"\"\"\n    self.graph = make_graph_directed(self.graph, origin)\n    self.origin = origin\n    return self.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.to_directed(origin)","title":"<code>origin</code>","text":"(<code>int</code>)           \u2013            <p>The node to use as the origin node for the directed graph. The origin node will have no incoming edges.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.to_json_file","title":"to_json_file","text":"<pre><code>to_json_file(file_path: str)\n</code></pre> <p>Return a JSON representation of the graph.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def to_json_file(self, file_path: str):\n    \"\"\"Return a JSON representation of the graph.\"\"\"\n    graph_dict = nx.node_link_data(self.graph, edges=\"edges\")\n    # if one of the attributes is not None, add it to the dict\n    # if not add a placeholder\n\n    object_dict = {\n        \"graph\": graph_dict,\n        \"origin\": self.origin,\n        \"image_path\": self.image_path,\n        \"image_key\": self.image_key,\n        \"voxel_size_um\": self.voxel_size_um,\n    }\n\n    with open(file_path, \"w\") as file:\n        json.dump(object_dict, file, indent=2, default=skeleton_graph_encoder)\n</code></pre>"},{"location":"reference/skeleplex/graph/constants/","title":"constants","text":""},{"location":"reference/skeleplex/graph/constants/#skeleplex.graph.constants","title":"skeleplex.graph.constants","text":"<p>Constants used for interacting with the graph objects.</p> <p>Generally, these are property or key names.</p>"},{"location":"reference/skeleplex/graph/image_to_graph/","title":"image_to_graph","text":""},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph","title":"skeleplex.graph.image_to_graph","text":"<p>Utilities to convert a skeleton image to a graph.</p> <p>Functions:</p> <ul> <li> <code>image_to_graph_skan</code>             \u2013              <p>Convert a skeleton image to a graph using skan.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph.image_to_graph_skan","title":"image_to_graph_skan","text":"<pre><code>image_to_graph_skan(skeleton_image: ndarray, max_spline_knots: int = 10) -&gt; MultiGraph\n</code></pre> <p>Convert a skeleton image to a graph using skan.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/image_to_graph.py</code> <pre><code>def image_to_graph_skan(\n    skeleton_image: np.ndarray, max_spline_knots: int = 10\n) -&gt; nx.MultiGraph:\n    \"\"\"Convert a skeleton image to a graph using skan.\n\n    Parameters\n    ----------\n    skeleton_image : np.ndarray\n        The image to convert to a skeleton graph.\n        The image should be a binary image and already skeletonized.\n    max_spline_knots : int\n        The maximum number of knots to use for the spline fit to the branch path.\n        If the number of data points in the branch is less than this number,\n        the spline will use n_data_points - 1 knots.\n        See the splinebox Spline class docs for more information.\n    \"\"\"\n    # make the skeleton\n    skeleton = SkanSkeleton(skeleton_image=skeleton_image)\n    summary_table = summarize(skeleton, separator=\"_\")\n\n    # get all of the nodes\n    # this might be slow - may need to speed up\n    # source_nodes = set(summary_table[\"node_id_src\"])\n    # destination_nodes = set(summary_table[\"node_id_dst\"])\n    # all_nodes = source_nodes.union(destination_nodes)\n\n    skeleton_graph = nx.MultiGraph()\n    for row in summary_table.itertuples(name=\"Edge\"):\n        # Iterate over the rows in the table.\n        # Each row is an edge in the graph\n        index = row.Index\n        i = row.node_id_src\n        j = row.node_id_dst\n\n        # fit a spline to the path\n        # todo: factor our to spline module\n        # todo: reconsider how the number of knots is set\n        spline_path = skeleton.path_coordinates(index)\n        n_points = len(spline_path)\n        if n_points &lt;= max_spline_knots:\n            n_spline_knots = n_points - 1\n        else:\n            n_spline_knots = max_spline_knots\n        spline = B3Spline.from_points(\n            points=spline_path,\n            n_knots=n_spline_knots,\n        )\n        # Nodes are added if they don't exist so only need to add edges\n        skeleton_graph.add_edge(\n            i,\n            j,\n            **{\"path\": spline_path, \"spline\": spline},\n        )\n\n    # add the node coordinates\n    new_node_data = {}\n    for node_index, node_data in skeleton_graph.nodes(data=True):\n        node_data[NODE_COORDINATE_KEY] = np.asarray(skeleton.coordinates[node_index])\n        new_node_data[node_index] = node_data\n\n    nx.set_node_attributes(skeleton_graph, new_node_data)\n\n    return skeleton_graph\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph.image_to_graph_skan(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The image to convert to a skeleton graph. The image should be a binary image and already skeletonized.</p>"},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph.image_to_graph_skan(max_spline_knots)","title":"<code>max_spline_knots</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of knots to use for the spline fit to the branch path. If the number of data points in the branch is less than this number, the spline will use n_data_points - 1 knots. See the splinebox Spline class docs for more information.</p>"},{"location":"reference/skeleplex/graph/modify_graph/","title":"modify_graph","text":""},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph","title":"skeleplex.graph.modify_graph","text":"<p>Functions:</p> <ul> <li> <code>delete_edge</code>             \u2013              <p>Delete edge in skeleton graph.</p> </li> <li> <code>length_pruning</code>             \u2013              <p>Prune all edges with length below threshold.</p> </li> <li> <code>merge_edge</code>             \u2013              <p>Merge edges in graph and add edge attributes.</p> </li> <li> <code>move_branch_point_along_edge</code>             \u2013              <p>Move Branch point along edge.</p> </li> <li> <code>split_edge</code>             \u2013              <p>Split an edge at a given position.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.delete_edge","title":"delete_edge","text":"<pre><code>delete_edge(skeleton_graph: SkeletonGraph, edge: tuple[int, int])\n</code></pre> <p>Delete edge in skeleton graph.</p> <p>To maintain a dichotomous structure, the edge is deleted and the resulting degree 2 node is merged with its neighbors.</p> <pre><code>    \"Delete (2,4)\"\n</code></pre> <p>1               1 |               | |               | 2------4   --&gt;  | |               | |               | 3               3</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def delete_edge(skeleton_graph: SkeletonGraph, edge: tuple[int, int]):\n    \"\"\"Delete edge in skeleton graph.\n\n    To maintain a dichotomous structure, the edge is deleted and the\n    resulting degree 2 node is merged with its neighbors.\n\n            \"Delete (2,4)\"\n    1               1\n    |               |\n    |               |\n    2------4   --&gt;  |\n    |               |\n    |               |\n    3               3\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The graph to delete the edge from.\n    edge : Tuple[int, int]\n        The edge to delete.\n    \"\"\"\n    # check if directed\n    if not skeleton_graph.graph.is_directed():\n        ValueError(\"Graph is not directed. Convert to directed graph.\")\n    # copy graph\n    graph = skeleton_graph.graph.copy()\n    graph.remove_edge(*edge)\n\n    # detect all changes\n    changed_edges = set(skeleton_graph.graph.edges) - set(graph.edges)\n    for edge in changed_edges:\n        for node in edge:\n            if graph.degree(node) == 0:\n                graph.remove_node(node)\n            # merge edges if node has degree 2\n            elif graph.degree(node) == 2:\n                # merge\n                in_edge = list(graph.in_edges(node))\n                out_edge = list(graph.out_edges(node))\n                if len(in_edge) == 0:\n                    raise ValueError(\n                        (\"Deleting the edge would break the graph\"),\n                        \"Are you trying to delete the origin?\",\n                    )\n\n                graph = merge_edge(graph, in_edge[0][0], node, out_edge[0][1])\n                logger.info(\"merge\")\n\n    # check if graph is still connected, if not remove orphaned nodes\n    skeleton_graph.graph.remove_nodes_from(list(nx.isolates(skeleton_graph.graph)))\n    skeleton_graph.graph = graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.delete_edge(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The graph to delete the edge from.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.delete_edge(edge)","title":"<code>edge</code>","text":"(<code>Tuple[int, int]</code>)           \u2013            <p>The edge to delete.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.length_pruning","title":"length_pruning","text":"<pre><code>length_pruning(skeleton_graph: SkeletonGraph, length_threshold: int)\n</code></pre> <p>Prune all edges with length below threshold.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def length_pruning(skeleton_graph: SkeletonGraph, length_threshold: int):\n    \"\"\"Prune all edges with length below threshold.\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The graph to prune.\n    length_threshold : int\n        The threshold for the length of the edges.\n\n\n    \"\"\"\n    # check if directed\n    if not skeleton_graph.graph.is_directed():\n        ValueError(\"Graph is not directed. Convert to directed graph.\")\n\n    graph = skeleton_graph.graph\n    g_unmodified = graph.copy()\n\n    # check if length is already computed\n    if len(nx.get_edge_attributes(graph, LENGTH_KEY)) == 0:\n        len_dict = skeleton_graph.compute_branch_lengths()\n        nx.set_edge_attributes(graph, len_dict, LENGTH_KEY)\n\n    for node, degree in g_unmodified.degree():\n        if (degree == 1) and (node != skeleton_graph.origin):\n            edge = next(iter(graph.in_edges(node)))\n            path_length = graph.edges[edge[0], edge[1]].get(LENGTH_KEY)\n            # start_node = edge[0]\n            if path_length &lt; length_threshold:\n                # check if edge still exists in original graph\n                if edge not in skeleton_graph.graph.edges:\n                    continue\n                try:\n                    delete_edge(skeleton_graph, edge)\n                    logger.info(f\"Deleted {edge}\")\n                except KeyError:\n                    logger.warning(f\"Edge {edge} not found in graph, could not delete.\")\n                except Exception as e:\n                    logger.error(f\"Unexpected error while deleting {edge}: {e}\")\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.length_pruning(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The graph to prune.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.length_pruning(length_threshold)","title":"<code>length_threshold</code>","text":"(<code>int</code>)           \u2013            <p>The threshold for the length of the edges.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge","title":"merge_edge","text":"<pre><code>merge_edge(graph: DiGraph, n1: int, v1: int, n2: int)\n</code></pre> <p>Merge edges in graph and add edge attributes.</p> <p>n1 is merged with n2. v1 is removed.</p> <pre><code>        \"n1 = 1, v1 = 2, n2 = 3\"\n</code></pre> <p>1               1 |               | |               | 2   --&gt;         | |               | |               | 3               3</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with the merged edge.</p> </li> </ul> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def merge_edge(graph: nx.DiGraph, n1: int, v1: int, n2: int):\n    \"\"\"Merge edges in graph and add edge attributes.\n\n    n1 is merged with n2. v1 is removed.\n\n                \"n1 = 1, v1 = 2, n2 = 3\"\n    1               1\n    |               |\n    |               |\n    2   --&gt;         |\n    |               |\n    |               |\n    3               3\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph to merge the edges in.\n    n1 : int\n        The start node of the first edge.\n    v1 : int\n        The end node of the first edge and the start node of the second edge.\n        This node is removed.\n    n2 : int\n        The end node of the second edge.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with the merged edge.\n\n\n\n    \"\"\"\n    graph = graph.copy()\n\n    start_node = graph.nodes(data=True)[n1][NODE_COORDINATE_KEY]\n    end_node = graph.nodes(data=True)[n2][NODE_COORDINATE_KEY]\n    middle_node = graph.nodes(data=True)[v1][NODE_COORDINATE_KEY]\n\n    edge1 = (start_node, middle_node)\n    edge2 = (middle_node, end_node)\n\n    edge_attributes1 = graph.get_edge_data(n1, v1)\n    edge_attributes2 = graph.get_edge_data(v1, n2)\n    graph.remove_edge(n1, v1)\n    graph.remove_edge(v1, n2)\n    graph.remove_node(v1)\n    merge_edge = (n1, n2)\n    merge_attributes = {}\n    for key in edge_attributes1:\n        if key == VALIDATION_KEY:\n            if edge_attributes1[key] and edge_attributes2[key]:\n                merge_attributes[key] = True\n            else:\n                merge_attributes[key] = False\n\n        if key == EDGE_SPLINE_KEY:\n            points1 = edge_attributes1[EDGE_COORDINATES_KEY]\n            points2 = edge_attributes2[EDGE_COORDINATES_KEY]\n\n            # start and end node coordinates\n            # this checking is probably not necessary as we use directed graphs\n            # but just to be sure\n            if np.allclose(points1[0], start_node) &amp; np.allclose(\n                points2[0], middle_node\n            ):\n                logger.info(\"None of the edges need to be flipped\")\n                spline_points = np.vstack((points1, points2))\n\n            elif np.allclose(points1[-1], start_node) &amp; np.allclose(\n                points2[0], middle_node\n            ):\n                logger.info(f\"flip edge {edge1}\")\n                spline_points = np.vstack((np.flip(points1, axis=0), points2))\n            elif np.allclose(points1[0], start_node) &amp; np.allclose(\n                points2[-1], middle_node\n            ):\n                logger.info(f\"flip {edge2}\")\n                spline_points = np.vstack((points1, np.flip(points2, axis=0)))\n            elif np.allclose(points1[-1], start_node) &amp; np.allclose(\n                points2[-1], middle_node\n            ):\n                logger.info(f\"flip {edge1} and {edge2}\")\n                spline_points = np.vstack(\n                    (np.flip(points1, axis=0), np.flip(points2, axis=0))\n                )\n            else:\n                logger.warning(\"Warning: Edge splines not connected.\")\n                spline_points = np.vstack((points1, points2))\n            # sanity check\n            if np.allclose(spline_points[-1], end_node):\n                logger.info(\"sanity check passed\")\n\n            _, idx = np.unique(spline_points, axis=0, return_index=True)\n            spline_points = spline_points[np.sort(idx)]\n            spline = B3Spline.from_points(spline_points)\n            merge_attributes[key] = spline\n            merge_attributes[EDGE_COORDINATES_KEY] = spline_points\n        if key == START_NODE_KEY:\n            merge_attributes[key] = n1\n        if key == END_NODE_KEY:\n            merge_attributes[key] = n2\n        if key == GENERATION_KEY:\n            merge_attributes[key] = edge_attributes1[key]\n\n        if key == LENGTH_KEY:\n            merge_attributes[key] = merge_attributes[EDGE_SPLINE_KEY].arc_length\n\n        if key not in [\n            VALIDATION_KEY,\n            EDGE_COORDINATES_KEY,\n            EDGE_SPLINE_KEY,\n            START_NODE_KEY,\n            END_NODE_KEY,\n            GENERATION_KEY,\n            LENGTH_KEY,\n        ]:\n            logger.warning(\n                (f\"Warning: Attribute {key} not merged. \", \"Consider recomputing.\")\n            )\n\n    graph.add_edge(*merge_edge, **merge_attributes)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph to merge the edges in.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge(n1)","title":"<code>n1</code>","text":"(<code>int</code>)           \u2013            <p>The start node of the first edge.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge(v1)","title":"<code>v1</code>","text":"(<code>int</code>)           \u2013            <p>The end node of the first edge and the start node of the second edge. This node is removed.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge(n2)","title":"<code>n2</code>","text":"(<code>int</code>)           \u2013            <p>The end node of the second edge.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge","title":"move_branch_point_along_edge","text":"<pre><code>move_branch_point_along_edge(skeleton_graph: SkeletonGraph, node: int, edge_to_shorten: tuple, edge_to_elongate: tuple, edge_to_remodel: tuple, distance)\n</code></pre> <p>Move Branch point along edge.</p> <p>Moves the branch point along the edge_to_shorten by distance and splits the edge_to_shorten at the new position. The second daughter edge is remoddled as a straight line.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def move_branch_point_along_edge(\n    skeleton_graph: SkeletonGraph,\n    node: int,\n    edge_to_shorten: tuple,\n    edge_to_elongate: tuple,\n    edge_to_remodel: tuple,\n    distance,\n):\n    \"\"\"\n    Move Branch point along edge.\n\n    Moves the branch point along the edge_to_shorten by distance and\n    splits the edge_to_shorten at the new position. The second daughter edge is\n    remoddled as a straight line.\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The skeleton graph object.\n    node : int\n        The node to move.\n    edge_to_shorten : Tuple\n        The edge to shorten.\n    edge_to_elongate : Tuple\n        The edge to elongate.\n    edge_to_remodel : Tuple\n        The edge to remodel.\n    distance : float\n        The distance to move the node along the edge_to_shorten.\n        Normalized between 0 and 1.\n    \"\"\"\n    graph = skeleton_graph.graph\n    spline_to_shorten = graph.edges[edge_to_shorten][EDGE_SPLINE_KEY]\n    # move branch point\n    point_on_edge_to_shorten = spline_to_shorten.eval(distance)\n\n    # split edge_coordinates into two parts at the point_on_in_edge\n    edge_to_shoorten_coords = graph.edges[edge_to_shorten][EDGE_COORDINATES_KEY]\n    # rather get the closest point\n    idx = np.argmin(\n        np.linalg.norm(edge_to_shoorten_coords - point_on_edge_to_shorten, axis=1)\n    )\n    # split\n    edge_coordinates_1 = edge_to_shoorten_coords[: idx + 1]\n    edge_coordinates_2 = edge_to_shoorten_coords[idx:]\n\n    # check if edge is long enough\n    if len(edge_coordinates_1) &lt; 4:\n        logger.warning(\n            f\"Edge {edge_to_shorten} is to short to split at {distance}.\"\n            \" Approximate edge as line.\"\n        )\n        edge_coordinates_1 = np.linspace(\n            edge_coordinates_1[0], edge_coordinates_1[-1], 5\n        )\n    out_edge_coordinates = graph.edges[edge_to_elongate][EDGE_COORDINATES_KEY]\n\n    # maybe it makes sense to take the sampled point of the spline,\n    # instead it takes the underlying coordinates. Could be more robust\n    new_node_pos = edge_to_shoorten_coords[idx]\n\n    new_out_edge_coordinates = np.concatenate(\n        (edge_coordinates_2, out_edge_coordinates)\n    )\n\n    # filter duplicates\n    new_out_edge_coordinates, indices = np.unique(\n        new_out_edge_coordinates, axis=0, return_index=True\n    )\n    new_out_edge_coordinates = new_out_edge_coordinates[np.argsort(indices)]\n\n    new_in_edge_coordinates = edge_coordinates_1\n\n    # update edges\n    graph.edges[edge_to_shorten][EDGE_COORDINATES_KEY] = new_in_edge_coordinates\n    graph.edges[edge_to_elongate][EDGE_COORDINATES_KEY] = new_out_edge_coordinates\n    graph.nodes[node][NODE_COORDINATE_KEY] = new_node_pos\n\n    # update splines\n    graph.edges[edge_to_shorten][EDGE_SPLINE_KEY] = B3Spline.from_points(\n        new_in_edge_coordinates\n    )\n    graph.edges[edge_to_elongate][EDGE_SPLINE_KEY] = B3Spline.from_points(\n        new_out_edge_coordinates\n    )\n\n    # draw new edge for the other out edge\n    out_edge_node2 = edge_to_remodel[1]\n    out_edge_node2_pos = graph.nodes[out_edge_node2][NODE_COORDINATE_KEY]\n    new_out_edge_coordinates = np.linspace(new_node_pos, out_edge_node2_pos, 10)\n\n    # update edge\n    graph.edges[edge_to_remodel][EDGE_COORDINATES_KEY] = new_out_edge_coordinates\n    graph.edges[edge_to_remodel][EDGE_SPLINE_KEY] = B3Spline.from_points(\n        new_out_edge_coordinates\n    )\n\n    # update graph\n    skeleton_graph.graph = graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The skeleton graph object.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(node)","title":"<code>node</code>","text":"(<code>int</code>)           \u2013            <p>The node to move.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(edge_to_shorten)","title":"<code>edge_to_shorten</code>","text":"(<code>Tuple</code>)           \u2013            <p>The edge to shorten.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(edge_to_elongate)","title":"<code>edge_to_elongate</code>","text":"(<code>Tuple</code>)           \u2013            <p>The edge to elongate.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(edge_to_remodel)","title":"<code>edge_to_remodel</code>","text":"(<code>Tuple</code>)           \u2013            <p>The edge to remodel.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(distance)","title":"<code>distance</code>","text":"(<code>float</code>)           \u2013            <p>The distance to move the node along the edge_to_shorten. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.split_edge","title":"split_edge","text":"<pre><code>split_edge(skeleton_graph: SkeletonGraph, edge_to_split_ID: tuple, split_pos: float)\n</code></pre> <p>Split an edge at a given position.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def split_edge(\n    skeleton_graph: SkeletonGraph, edge_to_split_ID: tuple, split_pos: float\n):\n    \"\"\"Split an edge at a given position.\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The skeleton graph object.\n    edge_to_split_ID : Tuple\n        The edge to split.\n    split_pos : float\n        The position to split the edge at. Normalized between 0 and 1.\n    \"\"\"\n    # test if edge is in tree\n    if edge_to_split_ID not in skeleton_graph.graph.edges:\n        ValueError(f\"Edge {edge_to_split_ID} not in graph.\")\n    graph = skeleton_graph.graph.copy()\n    spline = skeleton_graph.graph.edges[edge_to_split_ID][EDGE_SPLINE_KEY]\n    edge_coordinates = graph.edges[edge_to_split_ID][EDGE_COORDINATES_KEY]\n    coordinate_to_split = spline.eval(split_pos)\n    split_index = np.argmin(\n        np.linalg.norm(edge_coordinates - coordinate_to_split, axis=1)\n    )\n    new_node_number = get_next_node_key(graph)\n    graph.add_node(new_node_number, node_coordinate=coordinate_to_split)\n    new_edge_coords1 = edge_coordinates[: split_index + 1]\n    if len(new_edge_coords1) &lt; 4:\n        logger.warning(\n            f\"Edge {edge_to_split_ID} is to short to split at {split_pos}.\"\n            \" Approximate edge as line.\"\n        )\n        new_edge_coords1 = np.linspace(new_edge_coords1[0], new_edge_coords1[-1], 5)\n    new_edge_dict1 = {\n        EDGE_COORDINATES_KEY: new_edge_coords1,\n        START_NODE_KEY: new_node_number,\n        END_NODE_KEY: edge_to_split_ID[1],\n        EDGE_SPLINE_KEY: B3Spline.from_points(\n            new_edge_coords1,\n        ),\n    }\n    graph.add_edge(edge_to_split_ID[0], new_node_number, **new_edge_dict1)\n\n    # add second piece\n    new_edge_coords2 = edge_coordinates[split_index:]\n    if len(new_edge_coords2) &lt; 4:\n        logger.warning(\n            f\"Edge {edge_to_split_ID} is to short to split at {split_pos}.\"\n            \" Approximate edge as line.\"\n        )\n        new_edge_coords2 = np.linspace(new_edge_coords2[0], new_edge_coords2[-1], 5)\n\n    new_edge_dict2 = {\n        EDGE_COORDINATES_KEY: new_edge_coords2,\n        START_NODE_KEY: edge_to_split_ID[0],\n        END_NODE_KEY: new_node_number,\n        EDGE_SPLINE_KEY: B3Spline.from_points(\n            new_edge_coords2,\n        ),\n    }\n\n    graph.add_edge(new_node_number, edge_to_split_ID[1], **new_edge_dict2)\n\n    graph.remove_edge(*edge_to_split_ID)\n\n    skeleton_graph.graph = graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.split_edge(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The skeleton graph object.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.split_edge(edge_to_split_ID)","title":"<code>edge_to_split_ID</code>","text":"(<code>Tuple</code>)           \u2013            <p>The edge to split.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.split_edge(split_pos)","title":"<code>split_pos</code>","text":"(<code>float</code>)           \u2013            <p>The position to split the edge at. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/sample/","title":"sample","text":""},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample","title":"skeleplex.graph.sample","text":"<p>Functions for sampling images using the SkeletonGraph.</p> <p>Functions:</p> <ul> <li> <code>generate_2d_grid</code>             \u2013              <p>Generate a 2D sampling grid with specified shape and spacing.</p> </li> <li> <code>generate_3d_grid</code>             \u2013              <p>Generate a 3D sampling grid with specified shape and spacing.</p> </li> <li> <code>sample_volume_at_coordinates</code>             \u2013              <p>Sample a volume with spline interpolation at specific coordinates.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_2d_grid","title":"generate_2d_grid","text":"<pre><code>generate_2d_grid(grid_shape: tuple[int, int] = (10, 10), grid_spacing: tuple[float, float] = (1, 1)) -&gt; ndarray\n</code></pre> <p>Generate a 2D sampling grid with specified shape and spacing.</p> <p>The grid generated is centered on the origin, lying on the plane with normal vector [1, 0, 0], has shape (w, h, 3) for grid_shape (w, h), and spacing grid_spacing between neighboring points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Coordinate of points forming the 2D grid.</p> </li> </ul> Source code in <code>skeleplex/graph/sample.py</code> <pre><code>def generate_2d_grid(\n    grid_shape: tuple[int, int] = (10, 10), grid_spacing: tuple[float, float] = (1, 1)\n) -&gt; np.ndarray:\n    \"\"\"\n    Generate a 2D sampling grid with specified shape and spacing.\n\n    The grid generated is centered on the origin, lying on the plane with normal\n    vector [1, 0, 0], has shape (w, h, 3) for grid_shape (w, h), and spacing\n    grid_spacing between neighboring points.\n\n    Parameters\n    ----------\n    grid_shape : Tuple[int, int]\n        The number of grid points along each axis.\n    grid_spacing : Tuple[float, float]\n        Spacing between points in the sampling grid.\n\n    Returns\n    -------\n    np.ndarray\n        Coordinate of points forming the 2D grid.\n    \"\"\"\n    grid = generate_3d_grid(\n        grid_shape=(1, *grid_shape), grid_spacing=(1, *grid_spacing)\n    )\n    return einops.rearrange(grid, \"1 w h xyz -&gt; w h xyz\")\n</code></pre>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_2d_grid(grid_shape)","title":"<code>grid_shape</code>","text":"(<code>Tuple[int, int]</code>, default:                   <code>(10, 10)</code> )           \u2013            <p>The number of grid points along each axis.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_2d_grid(grid_spacing)","title":"<code>grid_spacing</code>","text":"(<code>Tuple[float, float]</code>, default:                   <code>(1, 1)</code> )           \u2013            <p>Spacing between points in the sampling grid.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_3d_grid","title":"generate_3d_grid","text":"<pre><code>generate_3d_grid(grid_shape: tuple[int, int, int] = (10, 10, 10), grid_spacing: tuple[float, float, float] = (1, 1, 1)) -&gt; ndarray\n</code></pre> <p>Generate a 3D sampling grid with specified shape and spacing.</p> <p>The grid generated is centered on the origin, has shape (w, h, d, 3) for grid_shape (w, h, d), and spacing grid_spacing between neighboring points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Coordinate of points forming the 3D grid.</p> </li> </ul> Source code in <code>skeleplex/graph/sample.py</code> <pre><code>def generate_3d_grid(\n    grid_shape: tuple[int, int, int] = (10, 10, 10),\n    grid_spacing: tuple[float, float, float] = (1, 1, 1),\n) -&gt; np.ndarray:\n    \"\"\"\n    Generate a 3D sampling grid with specified shape and spacing.\n\n    The grid generated is centered on the origin, has shape (w, h, d, 3) for\n    grid_shape (w, h, d), and spacing grid_spacing between neighboring points.\n\n    Parameters\n    ----------\n    grid_shape : Tuple[int, int, int]\n        The number of grid points along each axis.\n    grid_spacing : Tuple[float, float, float]\n        Spacing between points in the sampling grid.\n\n    Returns\n    -------\n    np.ndarray\n        Coordinate of points forming the 3D grid.\n    \"\"\"\n    # generate a grid of points at each integer from 0 to grid_shape for each dimension\n    grid = np.indices(grid_shape).astype(float)\n    grid = einops.rearrange(grid, \"xyz w h d -&gt; w h d xyz\")\n    # shift the grid to be centered on the origin\n    grid_offset = (np.array(grid_shape)) // 2\n    grid -= grid_offset\n    # scale the grid to get correct spacing\n    grid *= grid_spacing\n    return grid\n</code></pre>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_3d_grid(grid_shape)","title":"<code>grid_shape</code>","text":"(<code>Tuple[int, int, int]</code>, default:                   <code>(10, 10, 10)</code> )           \u2013            <p>The number of grid points along each axis.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_3d_grid(grid_spacing)","title":"<code>grid_spacing</code>","text":"(<code>Tuple[float, float, float]</code>, default:                   <code>(1, 1, 1)</code> )           \u2013            <p>Spacing between points in the sampling grid.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates","title":"sample_volume_at_coordinates","text":"<pre><code>sample_volume_at_coordinates(volume: ndarray, coordinates: ndarray, interpolation_order: int = 3, fill_value: float = nan) -&gt; ndarray\n</code></pre> <p>Sample a volume with spline interpolation at specific coordinates.</p> <p>The output shape is determined by the input coordinate shape such that if coordinates have shape (batch, grid_shape, 3), the output array will have shape (grid_shape, batch).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of shape (*grid_shape)</p> </li> </ul> Source code in <code>skeleplex/graph/sample.py</code> <pre><code>def sample_volume_at_coordinates(\n    volume: np.ndarray,\n    coordinates: np.ndarray,\n    interpolation_order: int = 3,\n    fill_value: float = np.nan,\n) -&gt; np.ndarray:\n    \"\"\"\n    Sample a volume with spline interpolation at specific coordinates.\n\n    The output shape is determined by the input coordinate shape such that\n    if coordinates have shape (batch, *grid_shape, 3), the output array will have\n    shape (*grid_shape, batch).\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        Volume to be sampled.\n    coordinates : np.ndarray\n        Array of coordinates at which to sample the volume. The shape of this array\n        should be (batch, *grid_shape, 3) to allow reshaping back correctly\n    interpolation_order : int\n        Spline order for image interpolation.\n    fill_value : float\n        Value to fill in for sample coordinates past the edges of the volume.\n\n    Returns\n    -------\n    np.ndarray\n        Array of shape (*grid_shape)\n    \"\"\"\n    batch, *grid_shape, _ = coordinates.shape\n    # map_coordinates wants transposed coordinate array\n    sampled_volume = map_coordinates(\n        volume,\n        coordinates.reshape(-1, 3).T,\n        order=interpolation_order,\n        cval=fill_value,\n    )\n\n    # reshape back (need to invert due to previous transposition)\n    sampled_volume = sampled_volume.reshape(*grid_shape, batch)\n    # and retranspose to get batch back to the 0th dimension\n    return einops.rearrange(sampled_volume, \"... batch -&gt; batch ...\")\n</code></pre>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>Volume to be sampled.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates(coordinates)","title":"<code>coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of coordinates at which to sample the volume. The shape of this array should be (batch, *grid_shape, 3) to allow reshaping back correctly</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Spline order for image interpolation.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates(fill_value)","title":"<code>fill_value</code>","text":"(<code>float</code>, default:                   <code>nan</code> )           \u2013            <p>Value to fill in for sample coordinates past the edges of the volume.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/","title":"skeleton_graph","text":""},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph","title":"skeleplex.graph.skeleton_graph","text":"<p>Data class for a skeleton graph.</p> <p>Classes:</p> <ul> <li> <code>SkeletonGraph</code>           \u2013            <p>Data class for a skeleton graph.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_next_node_key</code>             \u2013              <p>Return the next available node key in the graph.</p> </li> <li> <code>make_graph_directed</code>             \u2013              <p>Return a directed graph from an undirected graph.</p> </li> <li> <code>orient_splines</code>             \u2013              <p>Checks if the splines are oriented correctly.</p> </li> <li> <code>skeleton_graph_decoder</code>             \u2013              <p>JSON decoder for the networkx skeleton graph.</p> </li> <li> <code>skeleton_graph_encoder</code>             \u2013              <p>JSON encoder for the networkx skeleton graph.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph","title":"SkeletonGraph","text":"<pre><code>SkeletonGraph(graph: Graph, origin: int | None = None, image_path: str | None = None, image_key: str | None = None, voxel_size_um: float | None = None)\n</code></pre> <p>Data class for a skeleton graph.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>compute_branch_lengths</code>             \u2013              <p>Return a dictionary of edge lengths.</p> </li> <li> <code>from_graph</code>             \u2013              <p>Return a SkeletonGraph from a networkx graph.</p> </li> <li> <code>from_json_file</code>             \u2013              <p>Return a SkeletonGraph from a JSON file.</p> </li> <li> <code>from_skeleton_image</code>             \u2013              <p>Return a SkeletonGraph from a skeleton image.</p> </li> <li> <code>orient_splines</code>             \u2013              <p>Orient the splines in the graph.</p> </li> <li> <code>sample_volume_slices_from_spline</code>             \u2013              <p>Sample volume slices from the splines in the graph.</p> </li> <li> <code>to_directed</code>             \u2013              <p>Return a directed graph from the skeleton graph.</p> </li> <li> <code>to_json_file</code>             \u2013              <p>Return a JSON representation of the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>backend</code>               (<code>str</code>)           \u2013            <p>Return the backend used to store the graph.</p> </li> <li> <code>edge_splines</code>               (<code>dict</code>)           \u2013            <p>Return a list of edge splines.</p> </li> <li> <code>edges</code>           \u2013            <p>Return a list of edges.</p> </li> <li> <code>node_coordinates</code>               (<code>dict</code>)           \u2013            <p>Return a dictionary of node coordinates.</p> </li> <li> <code>node_coordinates_array</code>               (<code>ndarray</code>)           \u2013            <p>Return a numpy array of node coordinates.</p> </li> <li> <code>nodes</code>           \u2013            <p>Return a list of nodes.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def __init__(\n    self,\n    graph: nx.Graph,\n    origin: int | None = None,\n    image_path: str | None = None,\n    image_key: str | None = None,\n    voxel_size_um: float | None = None,\n):\n    self.graph = graph\n    self.origin = origin\n    self.image_path = image_path\n    self.image_key = image_key\n    self.voxel_size_um = voxel_size_um\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The skeleton graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(origin)","title":"<code>origin</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The origin node of the graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(image_path)","title":"<code>image_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image the graph was extracted from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(image_key)","title":"<code>image_key</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The key of the image in the image file.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(voxel_size_um)","title":"<code>voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the image in the image file. We keep the graph scaled to um for easier handling.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: str\n</code></pre> <p>Return the backend used to store the graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.edge_splines","title":"edge_splines  <code>property</code>","text":"<pre><code>edge_splines: dict\n</code></pre> <p>Return a list of edge splines.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.edges","title":"edges  <code>property</code>","text":"<pre><code>edges\n</code></pre> <p>Return a list of edges.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: dict\n</code></pre> <p>Return a dictionary of node coordinates.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.node_coordinates_array","title":"node_coordinates_array  <code>property</code>","text":"<pre><code>node_coordinates_array: ndarray\n</code></pre> <p>Return a numpy array of node coordinates.</p> <p>The array is of shape (n_nodes, n_dimensions). The order of the nodes is the same as the order of the nodes attribute.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Return a list of nodes.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.compute_branch_lengths","title":"compute_branch_lengths","text":"<pre><code>compute_branch_lengths() -&gt; dict\n</code></pre> <p>Return a dictionary of edge lengths.</p> <p>The keys of the dictionary are the edge tuples, the values are arc lengths of the fitted splines. Units will be the same as voxel scale.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def compute_branch_lengths(self) -&gt; dict:\n    \"\"\"Return a dictionary of edge lengths.\n\n    The keys of the dictionary are the edge tuples, the values are arc lengths\n    of the fitted splines. Units will be the same as voxel scale.\n    \"\"\"\n    edge_lengths = {}\n    for u, v, attr in self.graph.edges(data=True):\n        edge_lengths[(u, v)] = attr[EDGE_SPLINE_KEY].arc_length\n\n    nx.set_edge_attributes(self.graph, edge_lengths, LENGTH_KEY)\n    return edge_lengths\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph","title":"from_graph  <code>classmethod</code>","text":"<pre><code>from_graph(graph, edge_coordinate_key, node_coordinate_key) -&gt; SkeletonGraph\n</code></pre> <p>Return a SkeletonGraph from a networkx graph.</p> <p>The edges and nodes need to have an attribute with the specified keys containing the coordinates of the nodes and edges as an np.ndarray. Requires edge coordinates of length greater than 4 to successfully create a spline.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_graph(\n    cls, graph, edge_coordinate_key, node_coordinate_key\n) -&gt; \"SkeletonGraph\":\n    \"\"\"Return a SkeletonGraph from a networkx graph.\n\n    The edges and nodes need to have an attribute with the specified keys\n    containing the coordinates of the nodes and edges as an np.ndarray.\n    Requires edge coordinates of length greater than 4\n    to successfully create a spline.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        The graph to convert to a SkeletonGraph.\n    edge_coordinate_key : str\n        The key to use for the edge coordinates.\n    node_coordinate_key : str\n        The key to use for the node coordinates.\n    \"\"\"\n    graph_mod = graph.copy()\n    for _, _, attr in graph_mod.edges(data=True):\n        attr[EDGE_COORDINATES_KEY] = attr.pop(edge_coordinate_key)\n        # add spline\n        spline = B3Spline.from_points(attr[EDGE_COORDINATES_KEY])\n        attr[EDGE_SPLINE_KEY] = spline\n    for _, node_data in graph_mod.nodes(data=True):\n        node_data[NODE_COORDINATE_KEY] = node_data.pop(node_coordinate_key)\n    return cls(graph=graph_mod)\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The graph to convert to a SkeletonGraph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph(edge_coordinate_key)","title":"<code>edge_coordinate_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the edge coordinates.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph(node_coordinate_key)","title":"<code>node_coordinate_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the node coordinates.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_json_file","title":"from_json_file  <code>classmethod</code>","text":"<pre><code>from_json_file(file_path: str)\n</code></pre> <p>Return a SkeletonGraph from a JSON file.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_json_file(cls, file_path: str):\n    \"\"\"Return a SkeletonGraph from a JSON file.\"\"\"\n    with open(file_path) as file:\n        object_dict = json.load(file, object_hook=skeleton_graph_decoder)\n    graph = nx.node_link_graph(object_dict[\"graph\"], edges=\"edges\")\n    skeleton_object = cls(graph=graph)\n    # do only if keys exist\n    if \"origin\" in object_dict:\n        skeleton_object.origin = object_dict[\"origin\"]\n    if \"image_path\" in object_dict:\n        skeleton_object.image_path = object_dict[\"image_path\"]\n    if \"image_key\" in object_dict:\n        skeleton_object.image_key = object_dict[\"image_key\"]\n    if \"voxel_size_um\" in object_dict:\n        voxel_size_um = object_dict[\"voxel_size_um\"]\n        if voxel_size_um:\n            voxel_size_um = tuple(voxel_size_um)\n        skeleton_object.voxel_size_um = voxel_size_um\n\n    return skeleton_object\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_skeleton_image","title":"from_skeleton_image  <code>classmethod</code>","text":"<pre><code>from_skeleton_image(skeleton_image: ndarray, max_spline_knots: int = 10) -&gt; SkeletonGraph\n</code></pre> <p>Return a SkeletonGraph from a skeleton image.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_skeleton_image(\n    cls, skeleton_image: np.ndarray, max_spline_knots: int = 10\n) -&gt; \"SkeletonGraph\":\n    \"\"\"Return a SkeletonGraph from a skeleton image.\n\n    Parameters\n    ----------\n    skeleton_image : np.ndarray\n        The skeleton image to convert to a graph.\n    max_spline_knots : int\n        The maximum number of knots to use for the spline fit to the branch path.\n        If the number of data points in the branch is less than this number,\n        the spline will use n_data_points - 1 knots.\n        See the splinebox Spline class docs for more information.\n    \"\"\"\n    graph = image_to_graph_skan(\n        skeleton_image=skeleton_image, max_spline_knots=max_spline_knots\n    )\n    return cls(graph=graph)\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_skeleton_image(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton image to convert to a graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_skeleton_image(max_spline_knots)","title":"<code>max_spline_knots</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of knots to use for the spline fit to the branch path. If the number of data points in the branch is less than this number, the spline will use n_data_points - 1 knots. See the splinebox Spline class docs for more information.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.orient_splines","title":"orient_splines","text":"<pre><code>orient_splines() -&gt; DiGraph\n</code></pre> <p>Orient the splines in the graph.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def orient_splines(self) -&gt; nx.DiGraph:\n    \"\"\"Orient the splines in the graph.\"\"\"\n    self.graph = orient_splines(self.graph)\n    return self.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline","title":"sample_volume_slices_from_spline","text":"<pre><code>sample_volume_slices_from_spline(volume: ndarray, slice_spacing: float, slice_size: int, interpolation_order: int = 3, max_generation: int | None = None, segmentation: ndarray | None = None)\n</code></pre> <p>Sample volume slices from the splines in the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of image slices.</p> </li> <li> <code>Optional</code> (              <code>tuple(dict, dict)</code> )          \u2013            <p>A tuple of dictionaries of image and segmentation slices. Only if segmentation is not None.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def sample_volume_slices_from_spline(\n    self,\n    volume: np.ndarray,\n    slice_spacing: float,\n    slice_size: int,\n    interpolation_order: int = 3,\n    max_generation: int | None = None,\n    segmentation: np.ndarray | None = None,\n):\n    \"\"\"Sample volume slices from the splines in the graph.\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        The volume to sample slices from.\n    slice_spacing : float\n        The spacing between slices. Normalized between 0 and 1.\n    slice_size : int\n        The size of the slices in pixels.\n    interpolation_order : int\n        The order of the interpolation to use for the spline.\n        For labels use 0\n    max_generation : int\n        The maximum generation of the spline to sample.\n        If None, all levels are sampled.\n    segmentation : np.ndarray | None\n        The segmentation to sample slices from.\n        If None, only the image is sampled.\n\n    Returns\n    -------\n    dict\n        A dictionary of image slices.\n\n    Optional: tuple(dict, dict)\n        A tuple of dictionaries of image and segmentation slices.\n        Only if segmentation is not None.\n\n    \"\"\"\n    image_voxel_size_um = self.voxel_size_um\n\n    origin = self.origin\n    if not origin:\n        raise ValueError(\"No origin node provided. Please set origin.\")\n\n    if not image_voxel_size_um:\n        logger.warning(\"No voxel size provided. Assuming pixel size is 1 \u00b5m.\")\n        image_voxel_size_um = (1, 1, 1)\n\n    graph = self.graph.copy()\n    generation_dict = nx.get_edge_attributes(graph, GENERATION_KEY)\n    spline_dict = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n\n    # Scale the pixel size to the image voxel size\n    pixel_size = 1 / image_voxel_size_um[0]\n\n    image_slice_dict = {}\n    segmentation_slice_dict = {}\n\n    for u, v in nx.breadth_first_search.bfs_edges(graph, source=origin):\n        logger.info(f\"Sampling slices from edge ({u}, {v})\")\n\n        if max_generation and (generation_dict[(u, v)] &gt;= max_generation):\n            break\n        spline = spline_dict[(u, v)]\n        positions = np.linspace(0.1, 0.9, np.ceil(1 / slice_spacing).astype(int))\n        image_slice = spline.sample_volume_2d(\n            volume,\n            positions,\n            grid_shape=(slice_size, slice_size),\n            grid_spacing=(pixel_size, pixel_size),\n            sample_interpolation_order=interpolation_order,\n            image_voxel_size_um=image_voxel_size_um,\n        )\n        image_slice_dict[(u, v)] = image_slice\n\n        if segmentation is not None:\n            segmentation_slice = spline.sample_volume_2d(\n                segmentation,\n                positions,\n                grid_shape=(slice_size, slice_size),\n                grid_spacing=(pixel_size, pixel_size),\n                sample_interpolation_order=0,\n                image_voxel_size_um=image_voxel_size_um,\n            )\n            segmentation_slice_dict[(u, v)] = segmentation_slice\n\n    if segmentation is not None:\n        return image_slice_dict, segmentation_slice_dict\n    else:\n        return image_slice_dict\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The volume to sample slices from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(slice_spacing)","title":"<code>slice_spacing</code>","text":"(<code>float</code>)           \u2013            <p>The spacing between slices. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(slice_size)","title":"<code>slice_size</code>","text":"(<code>int</code>)           \u2013            <p>The size of the slices in pixels.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The order of the interpolation to use for the spline. For labels use 0</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(max_generation)","title":"<code>max_generation</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum generation of the spline to sample. If None, all levels are sampled.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(segmentation)","title":"<code>segmentation</code>","text":"(<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>The segmentation to sample slices from. If None, only the image is sampled.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.to_directed","title":"to_directed","text":"<pre><code>to_directed(origin: int) -&gt; DiGraph\n</code></pre> <p>Return a directed graph from the skeleton graph.</p> <p>The directed graph has the same nodes and edges as the skeleton graph. Stores the origin node as an attribute.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def to_directed(self, origin: int) -&gt; nx.DiGraph:\n    \"\"\"Return a directed graph from the skeleton graph.\n\n    The directed graph has the same nodes and edges as the skeleton graph.\n    Stores the origin node as an attribute.\n\n    Parameters\n    ----------\n    origin : int\n        The node to use as the origin node for the directed graph.\n        The origin node will have no incoming edges.\n    \"\"\"\n    self.graph = make_graph_directed(self.graph, origin)\n    self.origin = origin\n    return self.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.to_directed(origin)","title":"<code>origin</code>","text":"(<code>int</code>)           \u2013            <p>The node to use as the origin node for the directed graph. The origin node will have no incoming edges.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.to_json_file","title":"to_json_file","text":"<pre><code>to_json_file(file_path: str)\n</code></pre> <p>Return a JSON representation of the graph.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def to_json_file(self, file_path: str):\n    \"\"\"Return a JSON representation of the graph.\"\"\"\n    graph_dict = nx.node_link_data(self.graph, edges=\"edges\")\n    # if one of the attributes is not None, add it to the dict\n    # if not add a placeholder\n\n    object_dict = {\n        \"graph\": graph_dict,\n        \"origin\": self.origin,\n        \"image_path\": self.image_path,\n        \"image_key\": self.image_key,\n        \"voxel_size_um\": self.voxel_size_um,\n    }\n\n    with open(file_path, \"w\") as file:\n        json.dump(object_dict, file, indent=2, default=skeleton_graph_encoder)\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.get_next_node_key","title":"get_next_node_key","text":"<pre><code>get_next_node_key(graph: Graph) -&gt; int\n</code></pre> <p>Return the next available node key in the graph.</p> <p>This function assumes the graph node keys are integers.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The next available node key. If there are no nodes, the function returns 0.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def get_next_node_key(graph: nx.Graph) -&gt; int:\n    \"\"\"Return the next available node key in the graph.\n\n    This function assumes the graph node keys are integers.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        The graph to get the next node key from.\n\n    Returns\n    -------\n    int\n        The next available node key.\n        If there are no nodes, the function returns 0.\n    \"\"\"\n    node_numbers = list(graph.nodes)\n    node_numbers.sort()\n\n    if len(node_numbers) == 0:\n        return 0\n\n    free_node = node_numbers[0] + 1\n    while free_node in node_numbers:\n        node_numbers.pop(0)\n        free_node = node_numbers[0] + 1\n    return free_node\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.get_next_node_key(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The graph to get the next node key from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.make_graph_directed","title":"make_graph_directed","text":"<pre><code>make_graph_directed(graph: Graph, origin: int) -&gt; DiGraph\n</code></pre> <p>Return a directed graph from an undirected graph.</p> <p>The directed graph has the same nodes and edges as the undirected graph. If the graph is fragmented, meaning has multiple unconnected subgraphs, the function will choose the node with the highest degree as the origin node for each fragment.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def make_graph_directed(graph: nx.Graph, origin: int) -&gt; nx.DiGraph:\n    \"\"\"Return a directed graph from an undirected graph.\n\n    The directed graph has the same nodes and edges as the undirected graph.\n    If the graph is fragmented, meaning has multiple unconnected subgraphs,\n    the function will choose the node with the highest degree as the origin node\n    for each fragment.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        The undirected graph to convert to a directed graph.\n    origin : int\n        The node to use as the origin node for the directed graph.\n        The origin node will have no incoming edges.\n    \"\"\"\n    if isinstance(graph, nx.DiGraph):\n        logger.info(\"The input graph is already a directed graph.\")\n        return graph\n    if len(list(nx.connected_components(graph))) &gt; 1:\n        logger.warning(\"\"\"\n        The input graph is not connected.\n        The unconnected components might lose edges\n        \"\"\")\n        origin_part = nx.node_connected_component(graph, origin)\n        fragments = graph.subgraph(set(graph.nodes()) - origin_part)\n        graph = graph.subgraph(origin_part)\n    else:\n        fragments = None\n\n    di_graph = nx.DiGraph(graph)\n    di_graph.remove_edges_from(di_graph.edges - nx.bfs_edges(di_graph, origin))\n\n    if fragments:\n        # choose a node with the highest degree as the origin node\n        # Do this for each fragment\n        for fragment in nx.connected_components(fragments):\n            fragment_subgraph = fragments.subgraph(fragment)\n            \"\"\"Choose a origin of the fragment with the highest degree.\n            This is arbitrary but finding a better node\n            without knowledge were the network broke is hard\"\"\"\n            origin = max(fragment_subgraph.degree, key=lambda x: x[1])[0]\n            di_fragment = nx.DiGraph(fragment_subgraph)\n            di_fragment.remove_edges_from(\n                di_fragment.edges - nx.bfs_edges(di_fragment, origin)\n            )\n            di_graph.add_edges_from(di_fragment.edges(data=True))\n            di_graph.add_nodes_from(di_fragment.nodes(data=True))\n\n    return di_graph\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.make_graph_directed(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The undirected graph to convert to a directed graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.make_graph_directed(origin)","title":"<code>origin</code>","text":"(<code>int</code>)           \u2013            <p>The node to use as the origin node for the directed graph. The origin node will have no incoming edges.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.orient_splines","title":"orient_splines","text":"<pre><code>orient_splines(graph: DiGraph) -&gt; DiGraph\n</code></pre> <p>Checks if the splines are oriented correctly.</p> <p>If the beginning of the spline is closer to the end node than the start node, it gets flipped. Also checks if the edge coordinates are aligend with the spline. This only checks, if the splines are correctly connected to the nodes, not the order in the Graph. Best used on a directed graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with the splines oriented correctly.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def orient_splines(graph: nx.DiGraph) -&gt; nx.DiGraph:\n    \"\"\"Checks if the splines are oriented correctly.\n\n    If the beginning of the spline is closer to the end node than the start node,\n    it gets flipped.\n    Also checks if the edge coordinates are aligend with the spline.\n    This only checks, if the splines are correctly connected to the nodes,\n    not the order in the Graph. Best used on a directed graph.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph to orient the splines in.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with the splines oriented correctly.\n\n    \"\"\"\n    edge_spline_dict = {}\n    edge_coordinates_dict = {}\n\n    for u, v, attr in graph.edges(data=True):\n        spline = attr[EDGE_SPLINE_KEY]\n        u_coord = graph.nodes[u][NODE_COORDINATE_KEY]\n        spline_coordinates = spline.eval(np.array([0, 1]))\n        # check if spline evaluation is closer to the start or end node\n        if np.linalg.norm(u_coord - spline_coordinates[0]) &gt; np.linalg.norm(\n            u_coord - spline_coordinates[-1]\n        ):\n            logger.info(f\"Flipped spline of edge ({u,v}).\")\n            edge_coordinates = attr[EDGE_COORDINATES_KEY]\n            # check if path is inverse to spline\n            if np.linalg.norm(\n                edge_coordinates[0] - spline_coordinates[0]\n            ) &gt; np.linalg.norm(edge_coordinates[-1] - spline_coordinates[-1]):\n                edge_coordinates = edge_coordinates[::-1]\n\n            flipped_spline, flipped_cords = spline.flip_spline(edge_coordinates)\n            edge_spline_dict[(u, v)] = flipped_spline\n            edge_coordinates_dict[(u, v)] = flipped_cords\n\n    nx.set_edge_attributes(graph, edge_spline_dict, EDGE_SPLINE_KEY)\n    nx.set_edge_attributes(graph, edge_coordinates_dict, EDGE_COORDINATES_KEY)\n\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.orient_splines(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph to orient the splines in.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.skeleton_graph_decoder","title":"skeleton_graph_decoder","text":"<pre><code>skeleton_graph_decoder(json_object)\n</code></pre> <p>JSON decoder for the networkx skeleton graph.</p> <p>This function is to be used with the Python json.load(s) functions as the <code>object_hook</code> keyword argument.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def skeleton_graph_decoder(json_object):\n    \"\"\"JSON decoder for the networkx skeleton graph.\n\n    This function is to be used with the Python json.load(s) functions\n    as the `object_hook` keyword argument.\n    \"\"\"\n    if \"__class__\" in json_object:\n        # all custom classes are identified by the __class__ key\n        if json_object[\"__class__\"] == \"splinebox.Spline\":\n            json_object.pop(\"__class__\")\n            spline_kwargs = _prepared_dict_for_constructor(json_object)\n            return SplineboxSpline(**spline_kwargs)\n        if json_object[\"__class__\"] == \"skeleplex.B3Spline\":\n            return B3Spline.from_json_dict(json_object)\n\n    # Convert lists back to numpy arrays\n    for key, value in json_object.items():\n        if isinstance(value, list):\n            if key in [NODE_COORDINATE_KEY, EDGE_COORDINATES_KEY]:\n                try:\n                    json_object[key] = np.array(value)\n                except Exception:\n                    pass  # If conversion fails, keep it as a list\n\n            if key in [SISTER_EDGE_KEY, DAUGHTER_EDGES_KEY, PARENT_EDGE_KEY]:\n                if key == DAUGHTER_EDGES_KEY:\n                    json_object[key] = [tuple(edge) for edge in value]\n                else:\n                    json_object[key] = tuple(value)\n\n    return json_object\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.skeleton_graph_encoder","title":"skeleton_graph_encoder","text":"<pre><code>skeleton_graph_encoder(object_to_encode)\n</code></pre> <p>JSON encoder for the networkx skeleton graph.</p> <p>This function is to be used with the Python json.dump(s) functions as the <code>default</code> keyword argument.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def skeleton_graph_encoder(object_to_encode):\n    \"\"\"JSON encoder for the networkx skeleton graph.\n\n    This function is to be used with the Python json.dump(s) functions\n    as the `default` keyword argument.\n    \"\"\"\n    if isinstance(object_to_encode, np.ndarray):\n        return object_to_encode.tolist()\n    elif isinstance(object_to_encode, SplineboxSpline):\n        spline_dict = object_to_encode._to_dict(version=2)\n        if \"__class__\" in spline_dict:\n            raise ValueError(\n                \"The Spline object to encode already has a '__class__' key.\"\n            )\n        spline_dict.update({\"__class__\": \"splinebox.Spline\"})\n        return spline_dict\n    elif isinstance(object_to_encode, B3Spline):\n        return object_to_encode.to_json_dict()\n    raise TypeError(f\"Object of type {type(object_to_encode)} is not JSON serializable\")\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/","title":"spline","text":""},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline","title":"skeleplex.graph.spline","text":"<p>Utilities for fitting and working with splines.</p> <p>Classes:</p> <ul> <li> <code>B3Spline</code>           \u2013            <p>Model for a B3 spline.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline","title":"B3Spline","text":"<pre><code>B3Spline(model: Spline)\n</code></pre> <p>Model for a B3 spline.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>Evaluate the spline at a set of positions.</p> </li> <li> <code>flip_spline</code>             \u2013              <p>Recomputes the spline inverse to the path.</p> </li> <li> <code>from_json_dict</code>             \u2013              <p>Return a B3Spline from a JSON serializable dictionary.</p> </li> <li> <code>from_json_file</code>             \u2013              <p>Construct a B3Spline from a JSON file.</p> </li> <li> <code>from_points</code>             \u2013              <p>Construct a B3 spline fit to a list of points.</p> </li> <li> <code>moving_frame</code>             \u2013              <p>Generate a moving frame long the spline at specified positions.</p> </li> <li> <code>sample_volume_2d</code>             \u2013              <p>Sample a 3D image with 2D planes normal to the spline at specified positions.</p> </li> <li> <code>to_json_dict</code>             \u2013              <p>Return a JSON serializable dictionary.</p> </li> <li> <code>to_json_file</code>             \u2013              <p>Save the spline to a JSON file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>arc_length</code>               (<code>float</code>)           \u2013            <p>Return the arc length of the spline.</p> </li> <li> <code>model</code>               (<code>Spline</code>)           \u2013            <p>Return the underlying spline model.</p> </li> </ul> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def __init__(self, model: splinebox.Spline):\n    self._model = model\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline(model)","title":"<code>model</code>","text":"(<code>Spline</code>)           \u2013            <p>The spline model.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.arc_length","title":"arc_length  <code>property</code>","text":"<pre><code>arc_length: float\n</code></pre> <p>Return the arc length of the spline.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.model","title":"model  <code>property</code>","text":"<pre><code>model: Spline\n</code></pre> <p>Return the underlying spline model.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval","title":"eval","text":"<pre><code>eval(positions: ndarray, derivative: int = 0, approx: bool = False, atol: float = 1e-06) -&gt; ndarray\n</code></pre> <p>Evaluate the spline at a set of positions.</p> <p>Uses a quick conversion from normalized arc length coordinates to spline parameter coordinates. If approx is set to False, then arc_length_to_parameter is called instead. This uses a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates, but is slower.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def eval(\n    self,\n    positions: np.ndarray,\n    derivative: int = 0,\n    approx: bool = False,\n    atol: float = 1e-6,\n) -&gt; np.ndarray:\n    \"\"\"Evaluate the spline at a set of positions.\n\n    Uses a quick conversion from normalized arc length coordinates to\n    spline parameter coordinates. If approx is set to False, then\n    arc_length_to_parameter is called instead. This uses a binary search\n    to find the parameterized arc length that corresponds to the normalized\n    arc length coordinates, but is slower.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (n,) array of positions to evaluate the spline at.\n        The positions are normalized to the range [0, 1].\n    derivative : int\n        The order of the derivative to evaluate.\n        Default value is 0.\n    approx : bool\n        If True, use a quick conversion from normalized arc length\n        coordinates to spline parameter coordinates.\n        The more evenly spaced the spline knots are, the more accurate this\n        approximation becomes.\n        If False, use a binary search to find the parameterized arc length\n        that corresponds to the normalized arc length coordinates.\n        Default value is False.\n    atol : float\n        The absolute tolerance for converting the normalized\n        evaluation positions to positions along the spline.\n        Default value is 1e-6.\n\n    \"\"\"\n    if approx:\n        positions_t = positions * (self.model.M - 1)\n        # error computation is expensive, comment out for now\n        # error = self.model.arc_length(positions_t) - (positions * self.arc_length)\n        positions_t = np.asarray(positions_t)\n    else:\n        positions_t = self.model.arc_length_to_parameter(\n            positions * self.arc_length, atol=atol\n        )\n    # For single values, splinebox's eval expects a float\n    # This recasts the value to a float if positions_t is a single value\n    if positions_t.ndim == 0:\n        positions_t = positions_t.tolist()\n\n    return self.model.eval(positions_t, derivative=derivative)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(positions)","title":"<code>positions</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n,) array of positions to evaluate the spline at. The positions are normalized to the range [0, 1].</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(derivative)","title":"<code>derivative</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The order of the derivative to evaluate. Default value is 0.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use a quick conversion from normalized arc length coordinates to spline parameter coordinates. The more evenly spaced the spline knots are, the more accurate this approximation becomes. If False, use a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates. Default value is False.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(atol)","title":"<code>atol</code>","text":"(<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The absolute tolerance for converting the normalized evaluation positions to positions along the spline. Default value is 1e-6.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.flip_spline","title":"flip_spline","text":"<pre><code>flip_spline(path: ndarray) -&gt; B3Spline\n</code></pre> <p>Recomputes the spline inverse to the path.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>B3Spline</code>           \u2013            <p>The flipped spline.</p> </li> <li> <code>ndarray</code>           \u2013            <p>The flipped path coordinates.</p> </li> </ul> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def flip_spline(self, path: np.ndarray) -&gt; \"B3Spline\":\n    \"\"\"Recomputes the spline inverse to the path.\n\n    Parameters\n    ----------\n    path : np.ndarray\n        The coordinates to fit the spline to.\n\n    Returns\n    -------\n    B3Spline\n        The flipped spline.\n    np.ndarray\n        The flipped path coordinates.\n    \"\"\"\n    return self.from_points(path[::-1]), path[::-1]\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.flip_spline(path)","title":"<code>path</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates to fit the spline to.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_json_dict","title":"from_json_dict  <code>classmethod</code>","text":"<pre><code>from_json_dict(json_dict: dict) -&gt; B3Spline\n</code></pre> <p>Return a B3Spline from a JSON serializable dictionary.</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>@classmethod\ndef from_json_dict(cls, json_dict: dict) -&gt; \"B3Spline\":\n    \"\"\"Return a B3Spline from a JSON serializable dictionary.\"\"\"\n    if json_dict[\"backend\"] != cls._backend:\n        raise ValueError(\n            f\"Expected backend {cls._backend}, got {json_dict['backend']}.\"\n        )\n\n    # load the spline model\n    spline_model_dict = json_dict[\"model\"]\n\n    if isinstance(spline_model_dict, splinebox.Spline):\n        # model has already been deserialized\n        # this can happen if a this is being called\n        # within another JSON decoder.\n        return cls(model=spline_model_dict)\n\n    spline_model_dict.pop(\"__class__\")\n    spline_kwargs = _prepared_dict_for_constructor(spline_model_dict)\n    spline_model = splinebox.Spline(**spline_kwargs)\n\n    # make the class\n    return cls(model=spline_model)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_json_file","title":"from_json_file  <code>classmethod</code>","text":"<pre><code>from_json_file(file_path: str) -&gt; B3Spline\n</code></pre> <p>Construct a B3Spline from a JSON file.</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>@classmethod\ndef from_json_file(cls, file_path: str) -&gt; \"B3Spline\":\n    \"\"\"Construct a B3Spline from a JSON file.\"\"\"\n    with open(file_path) as file:\n        json_dict = json.load(file)\n    return cls.from_json_dict(json_dict)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_points","title":"from_points  <code>classmethod</code>","text":"<pre><code>from_points(points: ndarray, n_knots: int = 4)\n</code></pre> <p>Construct a B3 spline fit to a list of points.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>@classmethod\ndef from_points(cls, points: np.ndarray, n_knots: int = 4):\n    \"\"\"Construct a B3 spline fit to a list of points.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n, d) array of points to fit the spline to.\n        These must be ordered in the positive t direction\n        of the spline.\n    n_knots : int\n        The number of knots to use in the spline.\n    \"\"\"\n    basis_function = splinebox.B3()\n    spline = splinebox.Spline(\n        M=n_knots, basis_function=basis_function, closed=False\n    )\n    spline.fit(points)\n    return cls(model=spline)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_points(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n, d) array of points to fit the spline to. These must be ordered in the positive t direction of the spline.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_points(n_knots)","title":"<code>n_knots</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The number of knots to use in the spline.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.moving_frame","title":"moving_frame","text":"<pre><code>moving_frame(positions: ndarray, method: str = 'bishop', atol: float = 1e-06)\n</code></pre> <p>Generate a moving frame long the spline at specified positions.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def moving_frame(\n    self, positions: np.ndarray, method: str = \"bishop\", atol: float = 1e-6\n):\n    \"\"\"Generate a moving frame long the spline at specified positions.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (n,) array of positions to evaluate the spline at.\n        The positions are normalized to the range [0, 1].\n    method : str\n        The method to use for generating the moving frame.\n        Default value is \"bishop\".\n    atol : float\n        The absolute tolerance for converting the normalized\n        evaluation positions to positions along the spline.\n        Default value is 1e-6.\n    \"\"\"\n    # convert the normalized arc length coordinates to t\n    positions_t = self.model.arc_length_to_parameter(\n        positions * self.arc_length, atol=atol\n    )\n    return self.model.moving_frame(positions_t, method=method)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.moving_frame(positions)","title":"<code>positions</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n,) array of positions to evaluate the spline at. The positions are normalized to the range [0, 1].</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.moving_frame(method)","title":"<code>method</code>","text":"(<code>str</code>, default:                   <code>'bishop'</code> )           \u2013            <p>The method to use for generating the moving frame. Default value is \"bishop\".</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.moving_frame(atol)","title":"<code>atol</code>","text":"(<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The absolute tolerance for converting the normalized evaluation positions to positions along the spline. Default value is 1e-6.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d","title":"sample_volume_2d","text":"<pre><code>sample_volume_2d(volume: ndarray, positions: ndarray, grid_shape: tuple[int, int] = (10, 10), grid_spacing: tuple[float, float] = (1, 1), moving_frame_method: str = 'bishop', sample_interpolation_order: int = 3, sample_fill_value: float = nan, image_voxel_size_um: tuple[float, float, float] = (1, 1, 1))\n</code></pre> <p>Sample a 3D image with 2D planes normal to the spline at specified positions.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def sample_volume_2d(\n    self,\n    volume: np.ndarray,\n    positions: np.ndarray,\n    grid_shape: tuple[int, int] = (10, 10),\n    grid_spacing: tuple[float, float] = (1, 1),\n    moving_frame_method: str = \"bishop\",\n    sample_interpolation_order: int = 3,\n    sample_fill_value: float = np.nan,\n    image_voxel_size_um: tuple[float, float, float] = (1, 1, 1),\n):\n    \"\"\"Sample a 3D image with 2D planes normal to the spline at specified positions.\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        3D image to sample.\n    positions : np.ndarray\n        (n,) array of positions to evaluate the spline at.\n        The positions are normalized to the range [0, 1].\n    grid_shape : tuple[int, int]\n        The number of pixels along each axis of the resulting 2D image.\n        Default value is (10, 10).\n    grid_spacing : tuple[float, float]\n        Spacing between points in the sampling grid.\n        Default value is (1, 1).\n    moving_frame_method : str\n        The method to use for generating the moving frame.\n        Default value is \"bishop\".\n    sample_interpolation_order : int\n        The order of the spline interpolation to use when sampling the image.\n        Default value is 3.\n    sample_fill_value : float\n        The fill value to use when sampling the image outside\n        the bounds of the array. Default value is np.nan.\n    image_voxel_size_um : tuple[float, float, float]\n        The voxel size of the image.\n        Default value is (1, 1, 1).\n    \"\"\"\n    moving_frame = self.moving_frame(\n        positions=positions, method=moving_frame_method\n    )\n\n    # generate the grid of points for sampling the image\n    # (shape (w, h, 3))\n    sampling_grid = generate_2d_grid(\n        grid_shape=grid_shape, grid_spacing=grid_spacing\n    )\n\n    # reshape the sampling grid to be a list of coordinates\n    grid_coords = sampling_grid.reshape(-1, 3)\n\n    # apply each orientation to the grid for each position and store the result\n    rotated = []\n    for frame in moving_frame:\n        rotation_matrix = np.column_stack([frame[0], frame[1], frame[2]])\n        orientation = Rotation.from_matrix(rotation_matrix)\n        rotated.append(orientation.apply(grid_coords))\n\n    # get the coordinates of the points on the spline to center\n    # the sampling grid for the 2D image.\n    sample_centroid_coordinates = positions = self.eval(positions=positions)\n\n    # transform the grid to the image space\n    sample_centroid_coordinates = sample_centroid_coordinates / np.array(\n        image_voxel_size_um\n    )\n\n    # shift the rotated points to be centered on the spline\n    rotated_shifted = np.stack(rotated, axis=1) + sample_centroid_coordinates\n    placed_sample_grids = rotated_shifted.reshape(-1, *sampling_grid.shape)\n\n    return sample_volume_at_coordinates(\n        volume=volume,\n        coordinates=placed_sample_grids,\n        interpolation_order=sample_interpolation_order,\n        fill_value=sample_fill_value,\n    )\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D image to sample.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(positions)","title":"<code>positions</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n,) array of positions to evaluate the spline at. The positions are normalized to the range [0, 1].</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(grid_shape)","title":"<code>grid_shape</code>","text":"(<code>tuple[int, int]</code>, default:                   <code>(10, 10)</code> )           \u2013            <p>The number of pixels along each axis of the resulting 2D image. Default value is (10, 10).</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(grid_spacing)","title":"<code>grid_spacing</code>","text":"(<code>tuple[float, float]</code>, default:                   <code>(1, 1)</code> )           \u2013            <p>Spacing between points in the sampling grid. Default value is (1, 1).</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(moving_frame_method)","title":"<code>moving_frame_method</code>","text":"(<code>str</code>, default:                   <code>'bishop'</code> )           \u2013            <p>The method to use for generating the moving frame. Default value is \"bishop\".</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(sample_interpolation_order)","title":"<code>sample_interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The order of the spline interpolation to use when sampling the image. Default value is 3.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(sample_fill_value)","title":"<code>sample_fill_value</code>","text":"(<code>float</code>, default:                   <code>nan</code> )           \u2013            <p>The fill value to use when sampling the image outside the bounds of the array. Default value is np.nan.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(image_voxel_size_um)","title":"<code>image_voxel_size_um</code>","text":"(<code>tuple[float, float, float]</code>, default:                   <code>(1, 1, 1)</code> )           \u2013            <p>The voxel size of the image. Default value is (1, 1, 1).</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.to_json_dict","title":"to_json_dict","text":"<pre><code>to_json_dict() -&gt; dict\n</code></pre> <p>Return a JSON serializable dictionary.</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def to_json_dict(self) -&gt; dict:\n    \"\"\"Return a JSON serializable dictionary.\"\"\"\n    spline_model_dict = self.model._to_dict(version=2)\n    if \"__class__\" in spline_model_dict:\n        raise ValueError(\n            \"The Spline object to encode already has a '__class__' key.\"\n        )\n    spline_model_dict.update({\"__class__\": \"splinebox.Spline\"})\n    return {\n        \"__class__\": \"skeleplex.B3Spline\",\n        \"model\": spline_model_dict,\n        \"backend\": self._backend,\n    }\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.to_json_file","title":"to_json_file","text":"<pre><code>to_json_file(file_path: str) -&gt; None\n</code></pre> <p>Save the spline to a JSON file.</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def to_json_file(self, file_path: str) -&gt; None:\n    \"\"\"Save the spline to a JSON file.\"\"\"\n    with open(file_path, \"w\") as file:\n        json.dump(self.to_json_dict(), file)\n</code></pre>"},{"location":"reference/skeleplex/graph/utils/","title":"utils","text":""},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils","title":"skeleplex.graph.utils","text":"<p>Functions:</p> <ul> <li> <code>write_slices_to_h5</code>             \u2013              <p>Write image and segmentation slices to an h5 file.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5","title":"write_slices_to_h5","text":"<pre><code>write_slices_to_h5(file_path: str, file_base: str, image_slices: dict, segmentation_slices: dict | None = None, image_key: str = 'image', segmentation_key: str = 'segmentation')\n</code></pre> <p>Write image and segmentation slices to an h5 file.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/utils.py</code> <pre><code>def write_slices_to_h5(\n    file_path: str,\n    file_base: str,\n    image_slices: dict,\n    segmentation_slices: dict | None = None,\n    image_key: str = \"image\",\n    segmentation_key: str = \"segmentation\",\n):\n    \"\"\"\n    Write image and segmentation slices to an h5 file.\n\n    Parameters\n    ----------\n    file_path : str\n        The path to save to.\n    file_base : str\n        The base name of the file.\n    image_slices : dict\n        A dictionary of image slices. Keys are the edge IDs\n        of the edge the image slice belongs to.\n    segmentation_slices : dict, optional\n        A dictionary of segmentation slices. Keys are the edge IDs\n        of the edge the segmentation slice belongs to.\n    image_key : str\n        The key to use for the image slices.\n    segmentation_key : str\n        The key to use for the segmentation slices.\n    \"\"\"\n    if not os.path.exists(file_path):\n        os.makedirs(file_path)\n\n    for edge in image_slices.keys():\n        file_name = os.path.join(file_path, f\"{file_base}_sn_{edge[0]}_en_{edge[1]}.h5\")\n        logger.info(f\"Writing edge {edge} to {file_name}\")\n\n        with h5py.File(file_name, \"w\") as f:\n            f.create_dataset(image_key, data=image_slices[edge])\n            if segmentation_slices is not None:\n                f.create_dataset(segmentation_key, data=segmentation_slices[edge])\n</code></pre>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(file_path)","title":"<code>file_path</code>","text":"(<code>str</code>)           \u2013            <p>The path to save to.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(file_base)","title":"<code>file_base</code>","text":"(<code>str</code>)           \u2013            <p>The base name of the file.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(image_slices)","title":"<code>image_slices</code>","text":"(<code>dict</code>)           \u2013            <p>A dictionary of image slices. Keys are the edge IDs of the edge the image slice belongs to.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(segmentation_slices)","title":"<code>segmentation_slices</code>","text":"(<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of segmentation slices. Keys are the edge IDs of the edge the segmentation slice belongs to.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(image_key)","title":"<code>image_key</code>","text":"(<code>str</code>, default:                   <code>'image'</code> )           \u2013            <p>The key to use for the image slices.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(segmentation_key)","title":"<code>segmentation_key</code>","text":"(<code>str</code>, default:                   <code>'segmentation'</code> )           \u2013            <p>The key to use for the segmentation slices.</p>"},{"location":"reference/skeleplex/measurements/","title":"measurements","text":""},{"location":"reference/skeleplex/measurements/#skeleplex.measurements","title":"skeleplex.measurements","text":"<p>Tools to compute properties of a skeleton.</p> <p>Modules:</p> <ul> <li> <code>angles</code>           \u2013            </li> <li> <code>fit_surface</code>           \u2013            </li> <li> <code>graph_properties</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/skeleplex/measurements/angles/","title":"angles","text":""},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles","title":"skeleplex.measurements.angles","text":"<p>Functions:</p> <ul> <li> <code>compute_midline_branch_angle_branch_nodes</code>             \u2013              <p>Calculates the midline branch angle for each branch in the graph.</p> </li> <li> <code>compute_midline_branch_angle_spline</code>             \u2013              <p>Calculates the midline branch angle for each branch in the graph.</p> </li> <li> <code>compute_rotation_angle</code>             \u2013              <p>Calculates the rotation angle for each edge in the graph.</p> </li> <li> <code>compute_sibling_angle</code>             \u2013              <p>Calculates the sibling angle for each edge in the graph.</p> </li> <li> <code>compute_surface_normals_and_angles</code>             \u2013              <p>Computes surface normals and angles between surface normals and branch vectors.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_branch_nodes","title":"compute_midline_branch_angle_branch_nodes","text":"<pre><code>compute_midline_branch_angle_branch_nodes(graph: DiGraph)\n</code></pre> <p>Calculates the midline branch angle for each branch in the graph.</p> <p>Computes the midline anlges for each branch in the graph and returns the midline branch angle as an edge attribute.</p> <p>To compute the vectors, only the branch nodes are taken in consideration. Branches are simplified to a straight line between branch nodes.</p> <p>Graph requirements: - The graph must be directed - The graph must be ordered with the desired hierarchy - The graph must have a 'node_coordinate' attribute for each node</p> <p>Returns:</p> <ul> <li> <code>graph</code> (              <code>DiGraph</code> )          \u2013            <p>The input graph with the angles added as edge attributes</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the end point of the parent branch and the start point of the daughter branch are not the same</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the length of the midline vector is != 1</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the length of the branch vector is != 1</p> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>def compute_midline_branch_angle_branch_nodes(graph: nx.DiGraph):\n    \"\"\"Calculates the midline branch angle for each branch in the graph.\n\n    Computes the midline anlges for each branch in the graph and returns\n    the midline branch angle as an edge attribute.\n\n    To compute the vectors, only the branch nodes are taken in consideration.\n    Branches are simplified to a straight line between branch nodes.\n\n    Graph requirements:\n    - The graph must be directed\n    - The graph must be ordered with the desired hierarchy\n    - The graph must have a 'node_coordinate' attribute for each node\n\n    Returns\n    -------\n    graph : nx.DiGraph\n        The input graph with the angles added as edge attributes\n\n    Raises\n    ------\n    ValueError\n        Raises and error if the end point of the parent branch and the\n        start point of the daughter branch are not the same\n    ValueError\n        Raises and error if the length of the midline vector is != 1\n    ValueError\n        Raises and error if the length of the branch vector is != 1\n\n    \"\"\"\n    tree = graph.copy()\n\n    angle_dict = {}\n    center_points = []\n    midline_points = []\n\n    node_coordinates = nx.get_node_attributes(tree, \"node_coordinate\")\n\n    for u, v, _ in tree.edges(data=True):\n        edge = (u, v)\n        if not list(tree.in_edges(u)):\n            continue\n        parent_edge = next(iter(tree.in_edges(u)))\n\n        parent_start_node_coordinates = node_coordinates[parent_edge[0]]\n        parent_end_node_coordinates = node_coordinates[parent_edge[1]]\n\n        parent_vector = unit_vector(\n            parent_start_node_coordinates - parent_end_node_coordinates\n        )\n        midline_vector = -parent_vector\n\n        start_node_coordinates = node_coordinates[edge[0]]\n\n        if np.all(parent_end_node_coordinates != start_node_coordinates):\n            raise ValueError(\"Branch point ill defined.\")\n\n        end_node_coordinates = node_coordinates[edge[1]]\n        branch_vector = unit_vector(end_node_coordinates - start_node_coordinates)\n\n        if round(np.linalg.norm(midline_vector)) != 1:\n            raise ValueError(f\"\"\"Midline vector is not normalized.\n                             Its length is {np.linalg.norm(midline_vector)}\"\"\")\n        if round(np.linalg.norm(branch_vector)) != 1:\n            raise ValueError(f\"\"\"Branch vector is not normalized.\n                             Its length is {np.linalg.norm(branch_vector)}\"\"\")\n\n        dot = np.dot(midline_vector, branch_vector)\n        angle = np.degrees(np.arccos(dot))\n        # center around 90 degrees\n        # angle = np.abs(angle -90)\n        if angle &gt; 90:\n            angle = angle - 90\n\n        angle_dict[edge] = angle\n\n        # store for visualization\n        center_points.append(parent_end_node_coordinates)\n        midline_points.append(parent_end_node_coordinates + (50 * midline_vector))\n\n    nx.set_edge_attributes(tree, angle_dict, BRANCH_ANGLE_EDGE_KEY)\n\n    return tree, center_points, midline_points\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_spline","title":"compute_midline_branch_angle_spline","text":"<pre><code>compute_midline_branch_angle_spline(graph: DiGraph, n_samples: int, approx=False)\n</code></pre> <p>Calculates the midline branch angle for each branch in the graph.</p> <p>Computes the midline anlges for each branch in the graph and returns the midline branch angle as an edge attribute.</p> <p>To compute the vectors, the spline is used to sample points along the branch. Angles are computed between the tangent of the spline of the branch and the tangent of the spline of the parent branch. Sampling distance starts at the common node and moves towards the end of both branches.</p> <p>Graph requirements: - The graph must be directed - The graph must be ordered with the desired hierarchy - The graph must have a 'node_coordinate' attribute for each node</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>graph</code> (              <code>DiGraph</code> )          \u2013            <p>The input graph with the angles added as edge attributes</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the end point of the parent branch and the start point of the daughter branch are not the same</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the length of the midline vector is != 1</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the length of the branch vector is != 1</p> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>def compute_midline_branch_angle_spline(\n    graph: nx.DiGraph, n_samples: int, approx=False\n):\n    \"\"\"Calculates the midline branch angle for each branch in the graph.\n\n    Computes the midline anlges for each branch in the graph and returns\n    the midline branch angle as an edge attribute.\n\n    To compute the vectors, the spline is used to sample points along the\n    branch. Angles are computed between the tangent of the spline of the branch\n    and the tangent of the spline of the parent branch. Sampling distance starts\n    at the common node and moves towards the end of both branches.\n\n    Graph requirements:\n    - The graph must be directed\n    - The graph must be ordered with the desired hierarchy\n    - The graph must have a 'node_coordinate' attribute for each node\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph\n    n_samples : int\n        The number of samples to take along the spline\n    approx : bool\n        If True, evaluate the spline using an approximation\n\n    Returns\n    -------\n    graph : nx.DiGraph\n        The input graph with the angles added as edge attributes\n\n    Raises\n    ------\n    ValueError\n        Raises and error if the end point of the parent branch and the\n        start point of the daughter branch are not the same\n    ValueError\n        Raises and error if the length of the midline vector is != 1\n    ValueError\n        Raises and error if the length of the branch vector is != 1\n\n    \"\"\"\n    graph = graph.copy()\n    angle_dict = {}\n    # loop over each edge\n    for u, v in graph.edges():\n        edge = (u, v)\n        parent_edge = list(graph.in_edges(u))\n        if not parent_edge:\n            continue\n        parent_edge = parent_edge[0]\n        parent_spline = graph.edges[parent_edge][EDGE_SPLINE_KEY]\n        spline = graph.edges[edge][EDGE_SPLINE_KEY]\n        sample_positions = np.linspace(0, 1, n_samples)\n        parent_tangents = parent_spline.eval(\n            sample_positions, derivative=1, approx=approx\n        )\n        tangents = spline.eval(sample_positions, derivative=1, approx=approx)\n        # normalize the tangents\n        tangents = [unit_vector(t) for t in tangents]\n        parent_tangents = [unit_vector(t) for t in parent_tangents]\n\n        angle_list = []\n\n        for i in range(len(tangents)):\n            t = tangents[i]\n            j = len(parent_tangents) - i - 1\n            pt = parent_tangents[j]\n            dot = np.dot(t, pt)\n            angle = np.degrees(np.arccos(dot))\n            # center around 90 deg\n            # angle =np.abs(angle - 90)\n            angle_list.append(angle)\n        # angle_std = np.std(angle_list)\n        mean_angle = np.mean(angle_list)\n        angle_dict[edge] = mean_angle\n\n    nx.set_edge_attributes(graph, angle_dict, BRANCH_ANGLE_EDGE_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_spline(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_spline(n_samples)","title":"<code>n_samples</code>","text":"(<code>int</code>)           \u2013            <p>The number of samples to take along the spline</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_spline(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, evaluate the spline using an approximation</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_rotation_angle","title":"compute_rotation_angle","text":"<pre><code>compute_rotation_angle(graph: DiGraph)\n</code></pre> <p>Calculates the rotation angle for each edge in the graph.</p> <p>Compute the rotation angle between the plane defined by the parent node and the plane defined by the edge and its sister.</p> <p>The edge attribute is defined in the ROTATION_ANGLE_EDGE_KEY constant.</p> <p>The input graph should have the following attributes:</p> <ul> <li>NODE_COORDINATE_KEY: The node coordinates</li> <li>SISTER_EDGE_KEY: The sister edge</li> <li>Directed graph with the correct orientation</li> <li>Strictly dichotomous tree</li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>def compute_rotation_angle(graph: nx.DiGraph):\n    \"\"\"Calculates the rotation angle for each edge in the graph.\n\n    Compute the rotation angle between the plane defined by the parent node\n    and the plane defined by the edge and its sister.\n\n    The edge attribute is defined in the\n    ROTATION_ANGLE_EDGE_KEY constant.\n\n    The input graph should have the following attributes:\n\n    - NODE_COORDINATE_KEY: The node coordinates\n    - SISTER_EDGE_KEY: The sister edge\n    - Directed graph with the correct orientation\n    - Strictly dichotomous tree\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph\n    \"\"\"\n    rotation_angle_dict = {}\n    graph = graph.copy()\n    node_coord = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for edge in graph.edges():\n        parent = list(graph.in_edges(edge[0]))\n\n        sister = None\n        if SISTER_EDGE_KEY in graph.edges[edge]:\n            sister = graph.edges[edge][SISTER_EDGE_KEY]\n\n        if not parent or not sister:\n            continue\n        parent = parent[0]\n        parent_sister = None\n        if SISTER_EDGE_KEY in graph.edges[parent]:\n            parent_sister = graph.edges[parent][SISTER_EDGE_KEY]\n\n        if not parent_sister:\n            continue\n\n        if isinstance(parent_sister[0], list):\n            parent_sister = tuple(parent_sister[0])\n        if isinstance(sister[0], list):\n            sister = tuple(sister[0])\n\n        parent_plane = [\n            node_coord[parent[0]],\n            node_coord[parent[1]],\n            node_coord[parent_sister[1]],\n        ]\n\n        edge_plane = [node_coord[edge[0]], node_coord[edge[1]], node_coord[sister[1]]]\n        if parent_plane and edge_plane:\n            normal_parent = get_normal_of_plane(\n                parent_plane[0], parent_plane[1], parent_plane[2]\n            )\n            normal_edge = get_normal_of_plane(\n                edge_plane[0], edge_plane[1], edge_plane[2]\n            )\n            normal_parent_unit = unit_vector(normal_parent)\n            normal_edge_unit = unit_vector(normal_edge)\n            rotation_angle = np.arccos(np.dot(normal_parent_unit, normal_edge_unit))\n            if rotation_angle &gt; np.pi / 2:\n                rotation_angle = np.pi - rotation_angle\n            rotation_angle_dict[edge] = rad2deg(rotation_angle)\n\n    nx.set_edge_attributes(graph, rotation_angle_dict, ROTATION_ANGLE_EDGE_KEY)\n\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_rotation_angle(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_sibling_angle","title":"compute_sibling_angle","text":"<pre><code>compute_sibling_angle(graph: DiGraph)\n</code></pre> <p>Calculates the sibling angle for each edge in the graph.</p> <p>Computes the sibling angles for each edge in the graph and returns the sibling angle as an edge attribute.</p> <p>The sibling angle is the angle between the edge and its sister edge.</p> <p>Graph requirements: - The graph must be directed - The graph must be ordered with the desired hierarchy - The graph must have a 'node_coordinate' attribute for each node</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>graph</code> (              <code>DiGraph</code> )          \u2013            <p>The input graph with the sibling angle added as edge attributes</p> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>def compute_sibling_angle(graph: nx.DiGraph):\n    \"\"\"Calculates the sibling angle for each edge in the graph.\n\n    Computes the sibling angles for each edge in the graph\n    and returns the sibling angle as an edge attribute.\n\n    The sibling angle is the angle between the edge and its sister edge.\n\n    Graph requirements:\n    - The graph must be directed\n    - The graph must be ordered with the desired hierarchy\n    - The graph must have a 'node_coordinate' attribute for each node\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph\n\n    Returns\n    -------\n    graph : nx.DiGraph\n        The input graph with the sibling angle added as edge attributes\n    \"\"\"\n    graph = graph.copy()\n    angle_dict = {}\n    sister_pairs = nx.get_edge_attributes(graph, SISTER_EDGE_KEY)\n    sister_pairs = [(edge, sister_pairs[edge]) for edge in sister_pairs]\n    # keep only one sister pair as they both have the same angle\n    unique_pairs = set()\n    for pair in sister_pairs:\n        if isinstance(pair[0][0], list) or isinstance(pair[1][0], list):\n            continue\n        pair = tuple(sorted(pair))\n        unique_pairs.add(pair)\n    unique_pairs = list(unique_pairs)\n\n    node_coordinates = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for sister_pair in unique_pairs:\n        edge = sister_pair[0]\n        sister = sister_pair[1]\n        shared_node_coord = node_coordinates[edge[0]]\n        edge_vector = unit_vector(node_coordinates[edge[1]] - shared_node_coord)\n        sister_vector = unit_vector(node_coordinates[sister[1]] - shared_node_coord)\n\n        dot = np.dot(edge_vector, sister_vector)\n        angle = np.degrees(np.arccos(dot))\n        angle_dict[edge] = angle\n        angle_dict[sister] = angle\n\n    nx.set_edge_attributes(graph, angle_dict, SIBLING_ANGLE_EDGE_KEY)\n\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_sibling_angle(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles","title":"compute_surface_normals_and_angles","text":"<pre><code>compute_surface_normals_and_angles(skeletons: list, stage_list: list, lobes: tuple = ('LeftLobe', 'InferiorLobe', 'MiddleLobe', 'SuperiorLobe', 'PostCavalLobe'), smooth=1000)\n</code></pre> <p>Computes surface normals and angles between surface normals and branch vectors.</p> <p>Fits surfaces, computes surface normals, and calculates the angle between surface normals and branch vectors for a list of skeletons.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>- list_dict_normal_dicts: List of dictionaries</code>           \u2013            <p>containing normal vectors for each lobe</p> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>def compute_surface_normals_and_angles(\n    skeletons: list,\n    stage_list: list,\n    lobes: tuple = (\n        \"LeftLobe\",\n        \"InferiorLobe\",\n        \"MiddleLobe\",\n        \"SuperiorLobe\",\n        \"PostCavalLobe\",\n    ),\n    smooth=1000,\n):\n    \"\"\"Computes surface normals and angles between surface normals and branch vectors.\n\n    Fits surfaces, computes surface normals, and calculates the angle between\n    surface normals and branch vectors for a list of skeletons.\n\n    Parameters\n    ----------\n    skeletons : list\n        List of SkeletonGraph objects\n    stage_list : list\n        List of stage names\n    lobes : tuple\n        Tuple of lobe names\n    smooth : int\n        Smoothing parameter for the surface fitting\n\n    Returns\n    -------\n    - list_dict_normal_dicts: List of dictionaries\n        containing normal vectors for each lobe\n    \"\"\"\n    list_dict_normal_dicts = []\n\n    surface_stage_dict = {}\n\n    for i, skeleton in enumerate(skeletons):\n        logger.info(f\"Processing stage {stage_list[i]}\")\n\n        dict_normal_dicts = {}\n        graph = skeleton.graph\n\n        # Fit surface and get normals\n        logger.info(\"Fitting surfaces and getting normals...\")\n        surface_dict = {}\n        for lobe in lobes:\n            logger.info(f\"Processing lobe {lobe}\")\n            normal_dict, _, surface = fit_surface_and_get_surface_normal_of_branches(\n                graph, lobe, smooth=smooth\n            )\n            dict_normal_dicts[lobe] = normal_dict\n            surface_dict[lobe] = surface\n\n        surface_stage_dict[stage_list[i]] = surface_dict\n\n        list_dict_normal_dicts.append(dict_normal_dicts)\n\n        # Compute angle between surface normal and branch\n        lobe_edge_dict = nx.get_edge_attributes(graph, LOBE_NAME_KEY)\n        splines = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n        node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n\n        logger.info(\"Computing angles...\")\n        for u, v in graph.edges():\n            edge = (u, v)\n            spline = splines[edge]\n            lobe_of_edge = lobe_edge_dict[edge]\n\n            if lobe_of_edge in [\"&lt;class 'str'&gt;\", \"nan\"]:\n                continue\n\n            u_coord = node_coords[u]\n            v_coord = spline.eval(0.01, approx=True)\n            edge_vector = unit_vector(v_coord - u_coord)\n\n            try:\n                surface_vector = dict_normal_dicts[lobe_of_edge][edge]\n            except KeyError:\n                continue\n\n            angle = np.arccos(np.dot(edge_vector, surface_vector))\n            angle = rad2deg(angle) - 90\n            graph.edges[edge][SURFACE_ANGLE_EDGE_KEY] = angle\n\n        skeleton.graph = graph\n\n    return list_dict_normal_dicts, surface_stage_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles(skeletons)","title":"<code>skeletons</code>","text":"(<code>list</code>)           \u2013            <p>List of SkeletonGraph objects</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles(stage_list)","title":"<code>stage_list</code>","text":"(<code>list</code>)           \u2013            <p>List of stage names</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles(lobes)","title":"<code>lobes</code>","text":"(<code>tuple</code>, default:                   <code>('LeftLobe', 'InferiorLobe', 'MiddleLobe', 'SuperiorLobe', 'PostCavalLobe')</code> )           \u2013            <p>Tuple of lobe names</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles(smooth)","title":"<code>smooth</code>","text":"(<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Smoothing parameter for the surface fitting</p>"},{"location":"reference/skeleplex/measurements/fit_surface/","title":"fit_surface","text":""},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface","title":"skeleplex.measurements.fit_surface","text":"<p>Functions:</p> <ul> <li> <code>distance_to_surface</code>             \u2013              <p>Computes the distance of a set of points to a surface defined by vertices and faces.</p> </li> <li> <code>extract_central_region</code>             \u2013              <p>Extracts the central region of the point cloud using PCA and a distance threshold.</p> </li> <li> <code>fit_surface_and_get_surface_normal_of_branches</code>             \u2013              <p>Fits a surface to the central region of a point cloud and calculate normals.</p> </li> <li> <code>fit_surface_and_get_surface_normal_of_nodes</code>             \u2013              <p>Fits a surface to the central region of a point cloud and calculate normals.</p> </li> <li> <code>fit_surface_to_pointcloud_rbf_pca</code>             \u2013              <p>Fits an radial basis function surface to a pointcloud using PCA.</p> </li> <li> <code>get_normal_of_closest_point</code>             \u2013              <p>Computes the normal of the surface at the closest point to a set of points.</p> </li> <li> <code>get_normal_of_closest_surface_point</code>             \u2013              <p>Computes the normal of the surface at the closest point to a set of points.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.distance_to_surface","title":"distance_to_surface","text":"<pre><code>distance_to_surface(vertices, faces, points)\n</code></pre> <p>Computes the distance of a set of points to a surface defined by vertices and faces.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>distances</code> (              <code>ndarray</code> )          \u2013            <p>An array of shape (n_points,) containing the distances of each point to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def distance_to_surface(vertices, faces, points):\n    \"\"\"\n    Computes the distance of a set of points to a surface defined by vertices and faces.\n\n    Parameters\n    ----------\n    vertices : np.ndarray\n        An array of shape (n_vertices, 3) containing the vertices of the surface.\n    faces : np.ndarray\n        An array of shape (n_faces, 3) containing the faces of the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    distances : np.ndarray\n        An array of shape (n_points,) containing the distances of each point\n        to the surface.\n    \"\"\"\n    mesh = tri.Trimesh(vertices, faces)\n    closest_point, distance, triangles = mesh.nearest.on_surface(points)\n    return closest_point, distance, triangles\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.distance_to_surface(vertices)","title":"<code>vertices</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_vertices, 3) containing the vertices of the surface.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.distance_to_surface(faces)","title":"<code>faces</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_faces, 3) containing the faces of the surface.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.distance_to_surface(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.extract_central_region","title":"extract_central_region","text":"<pre><code>extract_central_region(points, percentile=50)\n</code></pre> <p>Extracts the central region of the point cloud using PCA and a distance threshold.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>central_points</code> (              <code>ndarray</code> )          \u2013            <p>The extracted central points.</p> </li> <li> <code>pca</code> (              <code>PCA</code> )          \u2013            <p>The PCA transformation object.</p> </li> <li> <code>mean</code> (              <code>ndarray</code> )          \u2013            <p>Mean of the original point cloud.</p> </li> <li> <code>components</code> (              <code>ndarray</code> )          \u2013            <p>The principal component axes.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def extract_central_region(points, percentile=50):\n    \"\"\"\n    Extracts the central region of the point cloud using PCA and a distance threshold.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n_points, 3) array containing the 3D point cloud.\n    percentile : float\n        The percentage of points to keep (default 50% around the mean).\n\n    Returns\n    -------\n    central_points : np.ndarray\n        The extracted central points.\n    pca : PCA\n        The PCA transformation object.\n    mean : np.ndarray\n        Mean of the original point cloud.\n    components : np.ndarray\n        The principal component axes.\n    \"\"\"\n    # Center the points\n    mean = np.mean(points, axis=0)\n    centered_points = points - mean\n\n    # Apply PCA\n    pca = PCA(n_components=3)\n    pca.fit(centered_points)\n    components = pca.components_  # Principal axes\n\n    # Transform points into PCA space\n    aligned_points = centered_points @ components.T  # Manual projection\n\n    # Compute distances in PCA space (only in the XY plane)\n    distances = np.linalg.norm(aligned_points[:, :2], axis=1)\n    threshold = np.percentile(distances, percentile)\n\n    # Select only the central points\n    central_points = points[distances &lt; threshold]\n    return central_points, mean, components\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.extract_central_region(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_points, 3) array containing the 3D point cloud.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.extract_central_region(percentile)","title":"<code>percentile</code>","text":"(<code>float</code>, default:                   <code>50</code> )           \u2013            <p>The percentage of points to keep (default 50% around the mean).</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_branches","title":"fit_surface_and_get_surface_normal_of_branches","text":"<pre><code>fit_surface_and_get_surface_normal_of_branches(graph: DiGraph, lobe_name: str, smooth=1000)\n</code></pre> <p>Fits a surface to the central region of a point cloud and calculate normals.</p> <p>The normals is the surface normal of the closest point on the surface to the branch midpoint.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normals</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its corresponding normal vector.</p> </li> <li> <code>distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its distance to the surface.</p> </li> <li> <code>(vertices, faces) : tuple</code>           \u2013            <p>The vertices and faces of the fitted surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def fit_surface_and_get_surface_normal_of_branches(\n    graph: nx.DiGraph, lobe_name: str, smooth=1000\n):\n    \"\"\"\n    Fits a surface to the central region of a point cloud and calculate normals.\n\n    The normals is the surface normal of the closest point on the\n    surface to the branch midpoint.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n         The graph containing the nodes.\n    lobe_name : str\n         The lobe to process.\n    smooth : float\n         RBF smoothing factor.\n\n    Returns\n    -------\n    normals : dict\n         A dictionary mapping each node to its corresponding normal vector.\n    distances : dict\n         A dictionary mapping each node to its distance to the surface.\n    (vertices, faces) : tuple\n         The vertices and faces of the fitted surface.\n    \"\"\"\n    # Extract the point cloud of the lobe\n    lobe_node_dict = {}\n    lobe_edge_ID_dict = {}\n\n    node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for u, v, lobe in graph.edges(data=LOBE_NAME_KEY):\n        if lobe not in lobe_node_dict:\n            lobe_node_dict[lobe] = []\n            lobe_edge_ID_dict[lobe] = []\n        lobe_node_dict[lobe].extend([node_coords[u], node_coords[v]])\n        lobe_edge_ID_dict[lobe].append((u, v))\n\n    lobe_coordinates = np.array(lobe_node_dict[lobe_name])\n    lobe_edges = lobe_edge_ID_dict[lobe_name]\n    vertices, faces = fit_surface_to_pointcloud_rbf_pca(\n        lobe_coordinates, smooth=smooth, percentile=100\n    )\n\n    mesh = tri.Trimesh(vertices, faces)\n\n    if not all(\"branch_midpoint\" in graph.edges[u, v] for u, v in graph.edges):\n        splines = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n        spline_midpoint_dict = {}\n        # get the midpoint of each spline\n        for edge, spline in splines.items():\n            spline_midpoint_dict[edge] = spline.eval(0.1, approx=True)\n    else:\n        spline_midpoint_dict = nx.get_edge_attributes(graph, \"branch_midpoint\")\n\n    lobe_midpoints = np.array([spline_midpoint_dict[key] for key in lobe_edges])\n\n    normal_dict, distance_dict = get_normal_of_closest_point(mesh, lobe_midpoints)\n\n    edge_normal_dict = {}\n    edge_distance_dict = {}\n\n    # Assign the normals and distances to the edges\n    for edge in lobe_edges:\n        edge_normal_dict[edge] = normal_dict[tuple(spline_midpoint_dict[edge])]\n        edge_distance_dict[edge] = distance_dict[tuple(spline_midpoint_dict[edge])]\n\n    return edge_normal_dict, edge_distance_dict, (vertices, faces)\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_branches(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph containing the nodes.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_branches(lobe_name)","title":"<code>lobe_name</code>","text":"(<code>str</code>)           \u2013            <p>The lobe to process.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_branches(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_nodes","title":"fit_surface_and_get_surface_normal_of_nodes","text":"<pre><code>fit_surface_and_get_surface_normal_of_nodes(graph: DiGraph, lobe_name: str, smooth=1000)\n</code></pre> <p>Fits a surface to the central region of a point cloud and calculate normals.</p> <p>The normals is the surface normal of the closest point on the surface to the node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normals</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its corresponding normal vector.</p> </li> <li> <code>distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its distance to the surface.</p> </li> <li> <code>(vertices, faces) : tuple</code>           \u2013            <p>The vertices and faces of the fitted surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def fit_surface_and_get_surface_normal_of_nodes(\n    graph: nx.DiGraph, lobe_name: str, smooth=1000\n):\n    \"\"\"\n    Fits a surface to the central region of a point cloud and calculate normals.\n\n    The normals is the surface normal of the closest point on the surface to the node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph containing the nodes.\n    lobe_name : str\n        The lobe to process.\n    smooth : float\n        RBF smoothing factor.\n\n    Returns\n    -------\n    normals : dict\n        A dictionary mapping each node to its corresponding normal vector.\n    distances : dict\n        A dictionary mapping each node to its distance to the surface.\n    (vertices, faces) : tuple\n        The vertices and faces of the fitted surface.\n    \"\"\"\n    # Extract the point cloud of the lobe\n    lobe_node_dict = {}\n    node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for u, v, lobe in graph.edges(data=LOBE_NAME_KEY):\n        if lobe not in lobe_node_dict:\n            lobe_node_dict[lobe] = []\n        lobe_node_dict[lobe].extend([node_coords[u], node_coords[v]])\n\n    lobe_points = np.array(lobe_node_dict[lobe_name])\n    vertices, faces = fit_surface_to_pointcloud_rbf_pca(\n        lobe_points, smooth=smooth, percentile=100\n    )\n    mesh = tri.Trimesh(vertices, faces)\n    normals, distances = get_normal_of_closest_point(mesh, lobe_points)\n    return normals, distances, (vertices, faces)\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_nodes(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph containing the nodes.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_nodes(lobe_name)","title":"<code>lobe_name</code>","text":"(<code>str</code>)           \u2013            <p>The lobe to process.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_nodes(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_to_pointcloud_rbf_pca","title":"fit_surface_to_pointcloud_rbf_pca","text":"<pre><code>fit_surface_to_pointcloud_rbf_pca(points: ndarray, smooth=0.2, percentile=100)\n</code></pre> <p>Fits an radial basis function surface to a pointcloud using PCA.</p> <p>Can be fitted to a central region of the pointcloud. PCA is used to find the principle axis of the point cloud at which axis the surface is fitted.</p> See Also <p>https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>vertices, faces : np.ndarray</code>           \u2013            <p>Mesh vertices and faces.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def fit_surface_to_pointcloud_rbf_pca(points: np.ndarray, smooth=0.2, percentile=100):\n    \"\"\"Fits an radial basis function surface to a pointcloud using PCA.\n\n    Can be fitted to a central region of the pointcloud.\n    PCA is used to find the principle axis of the point cloud at which axis the\n    surface is fitted.\n\n    See Also\n    --------\n    https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n_points, 3) array of 3D points.\n    smooth : float\n        RBF smoothing factor. 0 would fit the surface exactly to the points.\n        Thus to fit a surface through a pointcloud, a high value is recommended.\n    percentile : float\n        How much of the central region to retain (default 100%).\n\n    Returns\n    -------\n    vertices, faces : np.ndarray\n        Mesh vertices and faces.\n    \"\"\"\n    # Extract central region\n    central_points, mean, components = extract_central_region(points, percentile)\n\n    # Transform central points into PCA space\n    pca_space_points = (central_points - mean) @ components.T  # Manual projection\n\n    # Fit RBF surface on the central points in PCA space\n    x, y, z = pca_space_points[:, 0], pca_space_points[:, 1], pca_space_points[:, 2]\n    rbf = Rbf(x, y, z, function=\"multiquadric\", smooth=smooth)\n\n    # Generate a grid in PCA space\n    x_grid, y_grid = np.meshgrid(\n        np.linspace(np.min(x) - 50, np.max(x) + 50, 50),\n        np.linspace(np.min(y) - 50, np.max(y) + 50, 50),\n    )\n    z_grid = rbf(x_grid, y_grid)\n\n    # Reconstruct the surface back into original space\n    grid_points_pca = np.vstack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel())).T\n    original_grid_points = (\n        grid_points_pca @ components\n    ) + mean  # Correct transformation\n\n    # Build mesh\n    vertices = original_grid_points\n    tri = Delaunay(vertices[:, :2])\n    faces = tri.simplices\n\n    return vertices, faces\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_to_pointcloud_rbf_pca(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_points, 3) array of 3D points.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_to_pointcloud_rbf_pca(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>RBF smoothing factor. 0 would fit the surface exactly to the points. Thus to fit a surface through a pointcloud, a high value is recommended.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_to_pointcloud_rbf_pca(percentile)","title":"<code>percentile</code>","text":"(<code>float</code>, default:                   <code>100</code> )           \u2013            <p>How much of the central region to retain (default 100%).</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_point","title":"get_normal_of_closest_point","text":"<pre><code>get_normal_of_closest_point(mesh: Trimesh, points: ndarray)\n</code></pre> <p>Computes the normal of the surface at the closest point to a set of points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normal_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its corresponding normal vector.</p> </li> <li> <code>distance_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its distance to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def get_normal_of_closest_point(mesh: trimesh.Trimesh, points: np.ndarray):\n    \"\"\"Computes the normal of the surface at the closest point to a set of points.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The mesh representing the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    normal_dict : dict\n        A dictionary mapping each point to its corresponding normal vector.\n    distance_dict : dict\n        A dictionary mapping each point to its distance to the surface.\n    \"\"\"\n    if len(points.shape) == 1:\n        points = np.expand_dims(points, axis=0)\n\n    _, distance, closest_triangle = mesh.nearest.on_surface(points)\n    normals = tri.triangles.normals(mesh.triangles)[0]\n    normal_dict = {}\n    distance_dict = {}\n\n    for i in range(len(points)):\n        normal_dict[tuple(points[i])] = normals[closest_triangle[i]]\n        distance_dict[tuple(points[i])] = distance[i]\n\n    return normal_dict, distance_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_point(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The mesh representing the surface.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_point(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_surface_point","title":"get_normal_of_closest_surface_point","text":"<pre><code>get_normal_of_closest_surface_point(mesh: Trimesh, points: ndarray)\n</code></pre> <p>Computes the normal of the surface at the closest point to a set of points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normal_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its corresponding normal vector.</p> </li> <li> <code>distance_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its distance to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def get_normal_of_closest_surface_point(mesh: trimesh.Trimesh, points: np.ndarray):\n    \"\"\"Computes the normal of the surface at the closest point to a set of points.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The mesh representing the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    normal_dict : dict\n        A dictionary mapping each point to its corresponding normal vector.\n    distance_dict : dict\n        A dictionary mapping each point to its distance to the surface.\n    \"\"\"\n    # Find the closest point on the surface\n    _, distance, closest_triangle = mesh.nearest.on_surface(points)\n    normals = trimesh.triangles.normals(mesh.triangles)[0]\n    normal_dict = {}\n    distance_dict = {}\n    for i in range(len(points)):\n        normal_dict[tuple(points[i])] = normals[closest_triangle[i]]\n        distance_dict[tuple(points[i])] = distance[i]\n\n    return normal_dict, distance_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_surface_point(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The mesh representing the surface.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_surface_point(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/","title":"graph_properties","text":""},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties","title":"skeleplex.measurements.graph_properties","text":"<p>Functions:</p> <ul> <li> <code>compute_branch_length</code>             \u2013              <p>Compute the length of each branch in the graph.</p> </li> <li> <code>compute_level</code>             \u2013              <p>Compute the level of each node and edge in the graph.</p> </li> <li> <code>compute_number_of_tips_connected_to_edges</code>             \u2013              <p>Compute the number of tips connected to each edge in the graph.</p> </li> <li> <code>count_number_of_tips_connected_to_edge</code>             \u2013              <p>Count the number of tips connected to an edge in the graph.</p> </li> <li> <code>get_daughter_edges</code>             \u2013              <p>Return a graph with daughter edges annotated.</p> </li> <li> <code>get_parent_edges</code>             \u2013              <p>Return a graph with parent edges annotated.</p> </li> <li> <code>get_sister_edges</code>             \u2013              <p>Return a graph with sister edges annotated.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_branch_length","title":"compute_branch_length","text":"<pre><code>compute_branch_length(graph)\n</code></pre> <p>Compute the length of each branch in the graph.</p> <p>The length of a branch is the path length between its start and end nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with branch lengths annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def compute_branch_length(graph):\n    \"\"\"Compute the length of each branch in the graph.\n\n    The length of a branch is the path length between its start and end nodes.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with branch lengths annotated.\n    \"\"\"\n    graph = graph.copy()\n    length_dir = {}\n    for u, v in graph.edges():\n        spline = graph[u][v][EDGE_SPLINE_KEY]\n        length = spline.arc_length\n        length_dir[(u, v)] = length\n    nx.set_edge_attributes(graph, length_dir, LENGTH_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_branch_length(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_level","title":"compute_level","text":"<pre><code>compute_level(graph: DiGraph, origin: int)\n</code></pre> <p>Compute the level of each node and edge in the graph.</p> <p>The level of a node is the shortest path length from the origin node. The level of an edge is the level of its start node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with node and edge levels annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def compute_level(graph: nx.DiGraph, origin: int):\n    \"\"\"Compute the level of each node and edge in the graph.\n\n    The level of a node is the shortest path length from the origin node.\n    The level of an edge is the level of its start node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n    origin : int\n        The origin node.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with node and edge levels annotated.\n    \"\"\"\n    level_dir = {}\n    graph = graph.copy()\n    for node in graph.nodes():\n        if nx.has_path(graph, origin, node):\n            level = nx.shortest_path_length(graph, origin, node)\n        else:\n            level = -1\n        level_dir[node] = level\n    nx.set_node_attributes(graph, level_dir, GENERATION_KEY)\n\n    # Set edge level to level of start node\n    level_dir = {}\n    for u, v in graph.edges():\n        node_level = graph.nodes[u][GENERATION_KEY]\n        level_dir[(u, v)] = node_level\n    nx.set_edge_attributes(graph, level_dir, GENERATION_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_level(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_level(origin)","title":"<code>origin</code>","text":"(<code>int</code>)           \u2013            <p>The origin node.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_number_of_tips_connected_to_edges","title":"compute_number_of_tips_connected_to_edges","text":"<pre><code>compute_number_of_tips_connected_to_edges(graph)\n</code></pre> <p>Compute the number of tips connected to each edge in the graph.</p> <p>The number of tips connected to an edge is the number of leaf nodes in the subtree rooted at the edge's end node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with the number of tips connected to each edge annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def compute_number_of_tips_connected_to_edges(graph):\n    \"\"\"Compute the number of tips connected to each edge in the graph.\n\n    The number of tips connected to an edge is the number of leaf nodes in the subtree\n    rooted at the edge's end node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with the number of tips connected to each edge annotated.\n    \"\"\"\n    graph = graph.copy()\n    num_tips_dir = {}\n    for u, v in graph.edges():\n        num_tips = count_number_of_tips_connected_to_edge(graph, u, v)\n        num_tips_dir[(u, v)] = num_tips\n    nx.set_edge_attributes(graph, num_tips_dir, NUMBER_OF_TIPS_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_number_of_tips_connected_to_edges(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.count_number_of_tips_connected_to_edge","title":"count_number_of_tips_connected_to_edge","text":"<pre><code>count_number_of_tips_connected_to_edge(graph, start_node, end_node)\n</code></pre> <p>Count the number of tips connected to an edge in the graph.</p> <p>The number of tips connected to an edge is the number of leaf nodes in the subtree rooted at the edge's end node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of tips connected to the edge.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def count_number_of_tips_connected_to_edge(graph, start_node, end_node):\n    \"\"\"Count the number of tips connected to an edge in the graph.\n\n    The number of tips connected to an edge is the number of leaf nodes in the subtree\n    rooted at the edge's end node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n    start_node : int\n        The start node of the edge.\n    end_node : int\n        The end node of the edge.\n\n    Returns\n    -------\n    int\n        The number of tips connected to the edge.\n    \"\"\"\n    # Perform a breadth-first search starting from the end_node\n    subtree = nx.bfs_tree(graph, end_node)\n\n    # Initialize count of endpoints\n    num_endpoints = 0\n\n    # Iterate through nodes in the subtree\n    for node in subtree.nodes:\n        # Check if the node is a leaf node (degree 1) and is not the start_node\n        if subtree.degree(node) == 1 and node != start_node:\n            num_endpoints += 1\n\n    return num_endpoints\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.count_number_of_tips_connected_to_edge(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.count_number_of_tips_connected_to_edge(start_node)","title":"<code>start_node</code>","text":"(<code>int</code>)           \u2013            <p>The start node of the edge.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.count_number_of_tips_connected_to_edge(end_node)","title":"<code>end_node</code>","text":"(<code>int</code>)           \u2013            <p>The end node of the edge.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_daughter_edges","title":"get_daughter_edges","text":"<pre><code>get_daughter_edges(graph)\n</code></pre> <p>Return a graph with daughter edges annotated.</p> <p>This function identifies daughter edges for each edge in the graph. Daughter edges are edges that share the same end node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with daughter edges annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def get_daughter_edges(graph):\n    \"\"\"Return a graph with daughter edges annotated.\n\n    This function identifies daughter edges for each edge in the graph.\n    Daughter edges are edges that share the same end node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with daughter edges annotated.\n    \"\"\"\n    graph = graph.copy()\n    daughter_dict = {}\n    for edge in graph.edges():\n        daughters = list(graph.out_edges(edge[1]))\n        daughter_dict[edge] = daughters\n    nx.set_edge_attributes(graph, daughter_dict, DAUGHTER_EDGES_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_daughter_edges(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_parent_edges","title":"get_parent_edges","text":"<pre><code>get_parent_edges(graph: DiGraph)\n</code></pre> <p>Return a graph with parent edges annotated.</p> <p>This function identifies parent edges for each edge in the graph. Parent edges are edges that share the same start node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with parent edges annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def get_parent_edges(graph: nx.DiGraph):\n    \"\"\"Return a graph with parent edges annotated.\n\n    This function identifies parent edges for each edge in the graph.\n    Parent edges are edges that share the same start node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with parent edges annotated.\n    \"\"\"\n    graph = graph.copy()\n    parent_dict = {}\n    for edge in graph.edges():\n        parents = list(graph.in_edges(edge[0]))\n        parent_dict[edge] = parents\n    nx.set_edge_attributes(graph, parent_dict, PARENT_EDGE_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_parent_edges(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_sister_edges","title":"get_sister_edges","text":"<pre><code>get_sister_edges(graph: DiGraph)\n</code></pre> <p>Return a graph with sister edges annotated.</p> <p>This function identifies sister edges for each edge in the graph. Sister edges are edges that share the same start node but are not the same edge.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with sister edges annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def get_sister_edges(graph: nx.DiGraph):\n    \"\"\"Return a graph with sister edges annotated.\n\n    This function identifies sister edges for each edge in the graph.\n    Sister edges are edges that share the same start node but are not the same edge.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with sister edges annotated.\n    \"\"\"\n    graph = graph.copy()\n    sister_dict = {}\n    for edge in graph.edges():\n        sisters = list(graph.out_edges(edge[0]))\n        sister = [s for s in sisters if s != edge]\n        if len(sister) == 1:\n            sister_dict[edge] = sister[0]\n        elif len(sister) &gt; 1:\n            sister_dict[edge] = sister\n    nx.set_edge_attributes(graph, sister_dict, SISTER_EDGE_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_sister_edges(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/utils/","title":"utils","text":""},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils","title":"skeleplex.measurements.utils","text":"<p>Functions:</p> <ul> <li> <code>deg2rad</code>             \u2013              <p>Convert degrees to radians.</p> </li> <li> <code>distance_to_surface</code>             \u2013              <p>Computes the distance of a set of points to a surface defined by vertices and faces.</p> </li> <li> <code>ensure_same_normal_direction</code>             \u2013              <p>Ensure that all normals have the same direction.</p> </li> <li> <code>extract_central_region</code>             \u2013              <p>Extracts the central region of the point cloud using PCA and a distance threshold.</p> </li> <li> <code>fit_surface_and_get_surface_normal_of_branches</code>             \u2013              <p>Fits a surface to the central region of a point cloud and calculate normals.</p> </li> <li> <code>fit_surface_and_get_surface_normal_of_nodes</code>             \u2013              <p>Fits a surface to the central region of a point cloud and calculate normals.</p> </li> <li> <code>fit_surface_to_pointcloud_rbf_pca</code>             \u2013              <p>Fits an RBF surface to a pointcloud using PCA for rotation invariance.</p> </li> <li> <code>get_normal_of_closest_point</code>             \u2013              <p>Computes the normal of the surface at the closest point to a set of points.</p> </li> <li> <code>get_normal_of_closest_surface_point</code>             \u2013              <p>Computes the normal of the surface at the closest point to a set of points.</p> </li> <li> <code>get_normal_of_plane</code>             \u2013              <p>Get the normal vector of a plane defined by three points.</p> </li> <li> <code>graph_attributes_to_df</code>             \u2013              <p>Converts all edge attributes of a graph to a pandas dataframe.</p> </li> <li> <code>rad2deg</code>             \u2013              <p>Convert radians to degrees.</p> </li> <li> <code>rotation_matrix_from_vectors</code>             \u2013              <p>Compute the rotation matrix that rotates unit vector a onto unit vector b.</p> </li> <li> <code>unit_vector</code>             \u2013              <p>Returns the unit vector of the vector.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.deg2rad","title":"deg2rad","text":"<pre><code>deg2rad(deg)\n</code></pre> <p>Convert degrees to radians.</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def deg2rad(deg):\n    \"\"\"Convert degrees to radians.\"\"\"\n    return deg * np.pi / 180\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.distance_to_surface","title":"distance_to_surface","text":"<pre><code>distance_to_surface(vertices, faces, points)\n</code></pre> <p>Computes the distance of a set of points to a surface defined by vertices and faces.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>distances</code> (              <code>ndarray</code> )          \u2013            <p>An array of shape (n_points,) containing the distances of each point to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def distance_to_surface(vertices, faces, points):\n    \"\"\"\n    Computes the distance of a set of points to a surface defined by vertices and faces.\n\n    Parameters\n    ----------\n    vertices : np.ndarray\n        An array of shape (n_vertices, 3) containing the vertices of the surface.\n    faces : np.ndarray\n        An array of shape (n_faces, 3) containing the faces of the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    distances : np.ndarray\n        An array of shape (n_points,) containing the distances of each point\n        to the surface.\n    \"\"\"\n    mesh = tri.Trimesh(vertices, faces)\n    closest_point, distance, triangles = mesh.nearest.on_surface(points)\n    return closest_point, distance, triangles\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.distance_to_surface(vertices)","title":"<code>vertices</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_vertices, 3) containing the vertices of the surface.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.distance_to_surface(faces)","title":"<code>faces</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_faces, 3) containing the faces of the surface.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.distance_to_surface(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.ensure_same_normal_direction","title":"ensure_same_normal_direction","text":"<pre><code>ensure_same_normal_direction(normals: dict, reference_direction)\n</code></pre> <p>Ensure that all normals have the same direction.</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def ensure_same_normal_direction(normals: dict, reference_direction):\n    \"\"\"Ensure that all normals have the same direction.\"\"\"\n    for key, normal in normals.items():\n        if np.sign(normal[0]) != reference_direction:\n            logger.info(f\"Reversing normal for edge {key}\")\n            normals[key] = -normal  # Reverse the direction of the normal\n    return normals\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.extract_central_region","title":"extract_central_region","text":"<pre><code>extract_central_region(points, percentile=50)\n</code></pre> <p>Extracts the central region of the point cloud using PCA and a distance threshold.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>central_points</code> (              <code>ndarray</code> )          \u2013            <p>The extracted central points.</p> </li> <li> <code>pca</code> (              <code>PCA</code> )          \u2013            <p>The PCA transformation object.</p> </li> <li> <code>mean</code> (              <code>ndarray</code> )          \u2013            <p>Mean of the original point cloud.</p> </li> <li> <code>components</code> (              <code>ndarray</code> )          \u2013            <p>The principal component axes.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def extract_central_region(points, percentile=50):\n    \"\"\"\n    Extracts the central region of the point cloud using PCA and a distance threshold.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n_points, 3) array containing the 3D point cloud.\n    percentile : float\n        The percentage of points to keep (default 50% around the mean).\n\n    Returns\n    -------\n    central_points : np.ndarray\n        The extracted central points.\n    pca : PCA\n        The PCA transformation object.\n    mean : np.ndarray\n        Mean of the original point cloud.\n    components : np.ndarray\n        The principal component axes.\n    \"\"\"\n    # Center the points\n    mean = np.mean(points, axis=0)\n    centered_points = points - mean\n\n    # Apply PCA\n    pca = PCA(n_components=3)\n    pca.fit(centered_points)\n    components = pca.components_  # Principal axes\n\n    # Transform points into PCA space\n    aligned_points = centered_points @ components.T  # Manual projection\n\n    # Compute distances in PCA space (only in the XY plane)\n    distances = np.linalg.norm(aligned_points[:, :2], axis=1)\n    threshold = np.percentile(distances, percentile)\n\n    # Select only the central points\n    central_points = points[distances &lt; threshold]\n    return central_points, mean, components\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.extract_central_region(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_points, 3) array containing the 3D point cloud.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.extract_central_region(percentile)","title":"<code>percentile</code>","text":"(<code>float</code>, default:                   <code>50</code> )           \u2013            <p>The percentage of points to keep (default 50% around the mean).</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_branches","title":"fit_surface_and_get_surface_normal_of_branches","text":"<pre><code>fit_surface_and_get_surface_normal_of_branches(graph: DiGraph, lobe_name: str, smooth=1000)\n</code></pre> <p>Fits a surface to the central region of a point cloud and calculate normals.</p> <p>The normals is the surface normal of the closest point on the surface to the branch midpoint.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normals</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its corresponding normal vector.</p> </li> <li> <code>distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its distance to the surface.</p> </li> <li> <code>(vertices, faces) : tuple</code>           \u2013            <p>The vertices and faces of the fitted surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def fit_surface_and_get_surface_normal_of_branches(\n    graph: nx.DiGraph, lobe_name: str, smooth=1000\n):\n    \"\"\"\n    Fits a surface to the central region of a point cloud and calculate normals.\n\n    The normals is the surface normal of the closest point on the\n    surface to the branch midpoint.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n         The graph containing the nodes.\n    lobe_name : str\n         The lobe to process.\n    smooth : float\n         RBF smoothing factor.\n\n    Returns\n    -------\n    normals : dict\n         A dictionary mapping each node to its corresponding normal vector.\n    distances : dict\n         A dictionary mapping each node to its distance to the surface.\n    (vertices, faces) : tuple\n         The vertices and faces of the fitted surface.\n    \"\"\"\n    # Extract the point cloud of the lobe\n    lobe_node_dict = {}\n    lobe_edge_ID_dict = {}\n\n    node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for u, v, lobe in graph.edges(data=LOBE_NAME_KEY):\n        if lobe not in lobe_node_dict:\n            lobe_node_dict[lobe] = []\n            lobe_edge_ID_dict[lobe] = []\n        lobe_node_dict[lobe].extend([node_coords[u], node_coords[v]])\n        lobe_edge_ID_dict[lobe].append((u, v))\n\n    lobe_coordinates = np.array(lobe_node_dict[lobe_name])\n    lobe_edges = lobe_edge_ID_dict[lobe_name]\n    vertices, faces = fit_surface_to_pointcloud_rbf_pca(\n        lobe_coordinates, smooth=smooth, percentile=100\n    )\n\n    mesh = tri.Trimesh(vertices, faces)\n\n    if not all(\"branch_midpoint\" in graph.edges[u, v] for u, v in graph.edges):\n        splines = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n        spline_midpoint_dict = {}\n        # get the midpoint of each spline\n        for edge, spline in splines.items():\n            spline_midpoint_dict[edge] = spline.eval(0.5, approx=True)\n    else:\n        logger.info(\"Using existing branch midpoints\")\n        spline_midpoint_dict = nx.get_edge_attributes(graph, \"branch_midpoint\")\n\n    lobe_midpoints = np.array([spline_midpoint_dict[key] for key in lobe_edges])\n\n    normal_dict, distance_dict = get_normal_of_closest_point(mesh, lobe_midpoints)\n\n    edge_normal_dict = {}\n    edge_distance_dict = {}\n\n    # Assign the normals and distances to the edges\n    for edge in lobe_edges:\n        edge_normal_dict[edge] = normal_dict[tuple(spline_midpoint_dict[edge])]\n        edge_distance_dict[edge] = distance_dict[tuple(spline_midpoint_dict[edge])]\n\n    return edge_normal_dict, edge_distance_dict, (vertices, faces)\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_branches(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph containing the nodes.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_branches(lobe_name)","title":"<code>lobe_name</code>","text":"(<code>str</code>)           \u2013            <p>The lobe to process.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_branches(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_nodes","title":"fit_surface_and_get_surface_normal_of_nodes","text":"<pre><code>fit_surface_and_get_surface_normal_of_nodes(graph: DiGraph, lobe_name: str, smooth=1000)\n</code></pre> <p>Fits a surface to the central region of a point cloud and calculate normals.</p> <p>The normals is the surface normal of the closest point on the surface to the node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normals</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its corresponding normal vector.</p> </li> <li> <code>distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its distance to the surface.</p> </li> <li> <code>(vertices, faces) : tuple</code>           \u2013            <p>The vertices and faces of the fitted surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def fit_surface_and_get_surface_normal_of_nodes(\n    graph: nx.DiGraph, lobe_name: str, smooth=1000\n):\n    \"\"\"\n    Fits a surface to the central region of a point cloud and calculate normals.\n\n    The normals is the surface normal of the closest point on the surface to the node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph containing the nodes.\n    lobe_name : str\n        The lobe to process.\n    smooth : float\n        RBF smoothing factor.\n\n    Returns\n    -------\n    normals : dict\n        A dictionary mapping each node to its corresponding normal vector.\n    distances : dict\n        A dictionary mapping each node to its distance to the surface.\n    (vertices, faces) : tuple\n        The vertices and faces of the fitted surface.\n    \"\"\"\n    # Extract the point cloud of the lobe\n    lobe_node_dict = {}\n    node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for u, v, lobe in graph.edges(data=LOBE_NAME_KEY):\n        if lobe not in lobe_node_dict:\n            lobe_node_dict[lobe] = []\n        lobe_node_dict[lobe].extend([node_coords[u], node_coords[v]])\n\n    lobe_points = np.array(lobe_node_dict[lobe_name])\n    vertices, faces = fit_surface_to_pointcloud_rbf_pca(\n        lobe_points, smooth=smooth, percentile=100\n    )\n    mesh = tri.Trimesh(vertices, faces)\n    normals, distances = get_normal_of_closest_point(mesh, lobe_points)\n    return normals, distances, (vertices, faces)\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_nodes(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph containing the nodes.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_nodes(lobe_name)","title":"<code>lobe_name</code>","text":"(<code>str</code>)           \u2013            <p>The lobe to process.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_nodes(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_to_pointcloud_rbf_pca","title":"fit_surface_to_pointcloud_rbf_pca","text":"<pre><code>fit_surface_to_pointcloud_rbf_pca(points: ndarray, smooth=0.2, percentile=100)\n</code></pre> <p>Fits an RBF surface to a pointcloud using PCA for rotation invariance.</p> <p>Can be fitted to a central region of the pointcloud.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>vertices, faces : np.ndarray</code>           \u2013            <p>Mesh vertices and faces.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def fit_surface_to_pointcloud_rbf_pca(points: np.ndarray, smooth=0.2, percentile=100):\n    \"\"\"Fits an RBF surface to a pointcloud using PCA for rotation invariance.\n\n    Can be fitted to a central region of the pointcloud.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n_points, 3) array of 3D points.\n    smooth : float\n        RBF smoothing factor.\n    percentile : float\n        How much of the central region to retain (default 100%).\n\n    Returns\n    -------\n    vertices, faces : np.ndarray\n        Mesh vertices and faces.\n    \"\"\"\n    # Extract central region\n    central_points, mean, components = extract_central_region(points, percentile)\n\n    # Transform central points into PCA space\n    pca_space_points = (central_points - mean) @ components.T  # Manual projection\n\n    # Fit RBF surface on the central points in PCA space\n    x, y, z = pca_space_points[:, 0], pca_space_points[:, 1], pca_space_points[:, 2]\n    rbf = Rbf(x, y, z, function=\"multiquadric\", smooth=smooth)\n\n    # Generate a grid in PCA space\n    x_grid, y_grid = np.meshgrid(\n        np.linspace(np.min(x), np.max(x), 50), np.linspace(np.min(y), np.max(y), 50)\n    )\n    z_grid = rbf(x_grid, y_grid)\n\n    # Reconstruct the surface back into original space\n    grid_points_pca = np.vstack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel())).T\n    original_grid_points = (\n        grid_points_pca @ components\n    ) + mean  # Correct transformation\n\n    # Build mesh\n    vertices = original_grid_points\n    tri = Delaunay(vertices[:, :2])\n    faces = tri.simplices\n\n    return vertices, faces\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_to_pointcloud_rbf_pca(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_points, 3) array of 3D points.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_to_pointcloud_rbf_pca(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_to_pointcloud_rbf_pca(percentile)","title":"<code>percentile</code>","text":"(<code>float</code>, default:                   <code>100</code> )           \u2013            <p>How much of the central region to retain (default 100%).</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_point","title":"get_normal_of_closest_point","text":"<pre><code>get_normal_of_closest_point(mesh: Trimesh, points: ndarray)\n</code></pre> <p>Computes the normal of the surface at the closest point to a set of points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normal_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its corresponding normal vector.</p> </li> <li> <code>distance_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its distance to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def get_normal_of_closest_point(mesh: trimesh.Trimesh, points: np.ndarray):\n    \"\"\"Computes the normal of the surface at the closest point to a set of points.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The mesh representing the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    normal_dict : dict\n        A dictionary mapping each point to its corresponding normal vector.\n    distance_dict : dict\n        A dictionary mapping each point to its distance to the surface.\n    \"\"\"\n    if len(points.shape) == 1:\n        points = np.expand_dims(points, axis=0)\n\n    _, distance, closest_triangle = mesh.nearest.on_surface(points)\n    normals = tri.triangles.normals(mesh.triangles)[0]\n    normal_dict = {}\n    distance_dict = {}\n\n    for i in range(len(points)):\n        normal_dict[tuple(points[i])] = normals[closest_triangle[i]]\n        distance_dict[tuple(points[i])] = distance[i]\n\n    return normal_dict, distance_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_point(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The mesh representing the surface.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_point(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_surface_point","title":"get_normal_of_closest_surface_point","text":"<pre><code>get_normal_of_closest_surface_point(mesh: Trimesh, points: ndarray)\n</code></pre> <p>Computes the normal of the surface at the closest point to a set of points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normal_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its corresponding normal vector.</p> </li> <li> <code>distance_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its distance to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def get_normal_of_closest_surface_point(mesh: trimesh.Trimesh, points: np.ndarray):\n    \"\"\"Computes the normal of the surface at the closest point to a set of points.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The mesh representing the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    normal_dict : dict\n        A dictionary mapping each point to its corresponding normal vector.\n    distance_dict : dict\n        A dictionary mapping each point to its distance to the surface.\n    \"\"\"\n    # Find the closest point on the surface\n    _, distance, closest_triangle = mesh.nearest.on_surface(points)\n    normals = trimesh.triangles.normals(mesh.triangles)[0]\n    normal_dict = {}\n    distance_dict = {}\n    for i in range(len(points)):\n        normal_dict[tuple(points[i])] = normals[closest_triangle[i]]\n        distance_dict[tuple(points[i])] = distance[i]\n\n    return normal_dict, distance_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_surface_point(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The mesh representing the surface.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_surface_point(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_plane","title":"get_normal_of_plane","text":"<pre><code>get_normal_of_plane(p1: ndarray, p2: ndarray, p3: ndarray)\n</code></pre> <p>Get the normal vector of a plane defined by three points.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def get_normal_of_plane(p1: np.ndarray, p2: np.ndarray, p3: np.ndarray):\n    \"\"\"Get the normal vector of a plane defined by three points.\n\n    Parameters\n    ----------\n    p1 : np.ndarray\n        First point.\n    p2 : np.ndarray\n        Second point.\n    p3 : np.ndarray\n        Third point.\n\n    \"\"\"\n    v1 = p2 - p1\n    v2 = p3 - p1\n    cp = np.cross(v1, v2)\n    if all(cp == 0):\n        ValueError(\"The points are colinear\")\n    return cp\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_plane(p1)","title":"<code>p1</code>","text":"(<code>ndarray</code>)           \u2013            <p>First point.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_plane(p2)","title":"<code>p2</code>","text":"(<code>ndarray</code>)           \u2013            <p>Second point.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_plane(p3)","title":"<code>p3</code>","text":"(<code>ndarray</code>)           \u2013            <p>Third point.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.graph_attributes_to_df","title":"graph_attributes_to_df","text":"<pre><code>graph_attributes_to_df(graph: Graph)\n</code></pre> <p>Converts all edge attributes of a graph to a pandas dataframe.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>attr_df</code> (              <code>DataFrame</code> )          \u2013            <p>A pandas dataframe with all edge attributes</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def graph_attributes_to_df(graph: nx.Graph):\n    \"\"\"Converts all edge attributes of a graph to a pandas dataframe.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph to convert\n\n    Returns\n    -------\n    attr_df : pd.DataFrame\n        A pandas dataframe with all edge attributes\n\n    \"\"\"\n    attr_dict = {}\n    for u, v, attr in graph.edges(data=True):\n        attr_dict[(u, v)] = attr\n\n    attr_df = pd.DataFrame.from_dict(attr_dict, orient=\"index\").reset_index(drop=True)\n\n    return attr_df\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.graph_attributes_to_df(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph to convert</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.rad2deg","title":"rad2deg","text":"<pre><code>rad2deg(rad)\n</code></pre> <p>Convert radians to degrees.</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def rad2deg(rad):\n    \"\"\"Convert radians to degrees.\"\"\"\n    return rad * 180 / np.pi\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.rotation_matrix_from_vectors","title":"rotation_matrix_from_vectors","text":"<pre><code>rotation_matrix_from_vectors(a: ndarray, b: ndarray)\n</code></pre> <p>Compute the rotation matrix that rotates unit vector a onto unit vector b.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The rotation matrix.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def rotation_matrix_from_vectors(a: np.ndarray, b: np.ndarray):\n    \"\"\"Compute the rotation matrix that rotates unit vector a onto unit vector b.\n\n    Parameters\n    ----------\n    a : numpy.ndarray\n        The initial unit vector.\n    b : numpy.ndarray\n        The target unit vector.\n\n    Returns\n    -------\n    numpy.ndarray\n        The rotation matrix.\n    \"\"\"\n    # Compute the cross product and its magnitude\n    v = np.cross(a, b)\n    s = np.linalg.norm(v)\n\n    # Compute the dot product\n    c = np.dot(a, b)\n\n    # Skew-symmetric cross-product matrix\n    v_cross = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])\n\n    # Rotation matrix\n    if s != 0:\n        rm = np.eye(3) + v_cross + np.dot(v_cross, v_cross) * ((1 - c) / (s**2))\n    else:\n        rm = np.eye(3)\n\n    return R.from_matrix(rm)\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.rotation_matrix_from_vectors(a)","title":"<code>a</code>","text":"(<code>ndarray</code>)           \u2013            <p>The initial unit vector.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.rotation_matrix_from_vectors(b)","title":"<code>b</code>","text":"(<code>ndarray</code>)           \u2013            <p>The target unit vector.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.unit_vector","title":"unit_vector","text":"<pre><code>unit_vector(vector)\n</code></pre> <p>Returns the unit vector of the vector.</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def unit_vector(vector):\n    \"\"\"Returns the unit vector of the vector.\"\"\"\n    return np.squeeze(np.asarray(vector / np.linalg.norm(vector)))\n</code></pre>"},{"location":"reference/skeleplex/skeleton/","title":"skeleton","text":""},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton","title":"skeleplex.skeleton","text":"<p>Tools to create a skeleton image of a structure.</p> <p>Functions:</p> <ul> <li> <code>get_skeletonization_model</code>             \u2013              <p>Get a pretrained model from the SkelePlex repository.</p> </li> <li> <code>segment</code>             \u2013              <p>Segment the structures to be skeletonized.</p> </li> <li> <code>skeletonize</code>             \u2013              <p>Skeletonize a normalized distance field image.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.get_skeletonization_model","title":"get_skeletonization_model","text":"<pre><code>get_skeletonization_model() -&gt; MultiscaleSkeletonizationNet\n</code></pre> <p>Get a pretrained model from the SkelePlex repository.</p> <p>Returns:</p> <ul> <li> <code>MultiscaleSkeletonizationNet</code>           \u2013            <p>The pretrained skeletonization model.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_utils.py</code> <pre><code>def get_skeletonization_model() -&gt; MultiscaleSkeletonizationNet:\n    \"\"\"Get a pretrained model from the SkelePlex repository.\n\n    Returns\n    -------\n    MultiscaleSkeletonizationNet\n        The pretrained skeletonization model.\n    \"\"\"\n    # download the weights\n    file_path = SKELETONIZATION_MODEL_REGISTRY.fetch(\"skel-best.ckpt\")\n\n    return MultiscaleSkeletonizationNet.load_from_checkpoint(file_path)\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment","title":"segment","text":"<pre><code>segment(image: ndarray, model: Literal['pretrained'] | MultiscaleSemanticSegmentationNet = 'pretrained', roi_size: tuple[int, int, int] = (120, 120, 120), overlap: float = 0.5, stitching_mode: str = 'gaussian', progress_bar: bool = True, batch_size: int = 1) -&gt; ndarray\n</code></pre> <p>Segment the structures to be skeletonized.</p> <p>In the case of lungs, this would be used to segment the airways.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_segment.py</code> <pre><code>def segment(\n    image: np.ndarray,\n    model: Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    progress_bar: bool = True,\n    batch_size: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"Segment the structures to be skeletonized.\n\n    In the case of lungs, this would be used to segment the airways.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The input image to skeletonize.\n        This should be a normalized distance field image.\n    model : Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",\n        The model to use for prediction. This can either be an instance of\n        MultiscaleSemanticSegmentationNet or the string \"pretrained\". If \"pretrained\",\n        a pretrained model will be downloaded from the SkelePlex repository and used.\n        Default value is \"pretrained\".\n    roi_size : tuple[int, int, int]\n        The size of each tile to predict on.\n        The default value is (120, 120, 120).\n    overlap : float\n        The amount of overlap between tiles.\n        Should be between 0 and 1.\n        Default value is 0.5.\n    stitching_mode : str\n        The method to use to stitch overlapping tiles.\n        Should be \"gaussian\" or \"constant\".\n        \"gaussian\" uses a Gaussian kernel to weight the overlapping regions.\n        \"constant\" uses equal weight across overlapping regions.\n        \"gaussian\" is the default.\n    progress_bar : bool\n        Displays a progress bar during the prediction when set to True.\n        Default is True.\n    batch_size : int\n        The number of tiles to predict at once.\n        Default value is 1.\n    \"\"\"\n    # add dim -&gt; NCZYX\n    expanded_image = torch.from_numpy(make_image_5d(image))\n\n    # get the skeletonziation model if requested\n    if model == \"pretrained\":\n        raise NotImplementedError(\"pretrained segmentation models not implemented.\")\n\n    # put the model in eval mode\n    model.eval()\n\n    # make the prediction\n    with torch.no_grad():\n        result = sliding_window_inference(\n            inputs=expanded_image,\n            sw_batch_size=batch_size,\n            sw_device=torch.device(\"cuda\"),\n            predictor=model,\n            roi_size=roi_size,\n            overlap=overlap,\n            mode=stitching_mode,\n            device=torch.device(\"cpu\"),\n            progress=progress_bar,\n        )\n\n    # squeeze dims -&gt; ZYX\n    return torch.squeeze(torch.squeeze(result, dim=0), dim=0).numpy()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to skeletonize. This should be a normalized distance field image.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(model)","title":"<code>model</code>","text":"(<code>Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for prediction. This can either be an instance of MultiscaleSemanticSegmentationNet or the string \"pretrained\". If \"pretrained\", a pretrained model will be downloaded from the SkelePlex repository and used. Default value is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>The size of each tile to predict on. The default value is (120, 120, 120).</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The amount of overlap between tiles. Should be between 0 and 1. Default value is 0.5.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The method to use to stitch overlapping tiles. Should be \"gaussian\" or \"constant\". \"gaussian\" uses a Gaussian kernel to weight the overlapping regions. \"constant\" uses equal weight across overlapping regions. \"gaussian\" is the default.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(progress_bar)","title":"<code>progress_bar</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Displays a progress bar during the prediction when set to True. Default is True.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of tiles to predict at once. Default value is 1.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize","title":"skeletonize","text":"<pre><code>skeletonize(image: ndarray, model: Literal['pretrained'] | MultiscaleSkeletonizationNet = 'pretrained', roi_size: tuple[int, int, int] = (120, 120, 120), overlap: float = 0.5, stitching_mode: str = 'gaussian', progress_bar: bool = True, batch_size: int = 1) -&gt; ndarray\n</code></pre> <p>Skeletonize a normalized distance field image.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_skeletonize.py</code> <pre><code>def skeletonize(\n    image: np.ndarray,\n    model: Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    progress_bar: bool = True,\n    batch_size: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"Skeletonize a normalized distance field image.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The input image to skeletonize.\n        This should be a normalized distance field image.\n    model : Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",\n        The model to use for prediction. This can either be an instance of\n        MultiscaleSkeletonizationNet or the string \"pretrained\". If \"pretrained\",\n        a pretrained model will be downloaded from the SkelePlex repository and used.\n        Default value is \"pretrained\".\n    roi_size : tuple[int, int, int]\n        The size of each tile to predict on.\n        The default value is (120, 120, 120).\n    overlap : float\n        The amount of overlap between tiles.\n        Should be between 0 and 1.\n        Default value is 0.5.\n    stitching_mode : str\n        The method to use to stitch overlapping tiles.\n        Should be \"gaussian\" or \"constant\".\n        \"gaussian\" uses a Gaussian kernel to weight the overlapping regions.\n        \"constant\" uses equal weight across overlapping regions.\n        \"gaussian\" is the default.\n    progress_bar : bool\n        Displays a progress bar during the prediction when set to True.\n        Default is True.\n    batch_size : int\n        The number of tiles to predict at once.\n        Default value is 1.\n    \"\"\"\n    # add dim -&gt; NCZYX\n    expanded_image = torch.from_numpy(make_image_5d(image))\n\n    # get the skeletonziation model if requested\n    if model == \"pretrained\":\n        model = get_skeletonization_model()\n\n    # put the model in eval mode\n    model.eval()\n\n    # make the prediction\n    with torch.no_grad():\n        result = sliding_window_inference(\n            inputs=expanded_image,\n            sw_batch_size=batch_size,\n            sw_device=torch.device(\"cuda\"),\n            predictor=model,\n            roi_size=roi_size,\n            overlap=overlap,\n            mode=stitching_mode,\n            device=torch.device(\"cpu\"),\n            progress=progress_bar,\n        )\n\n    # squeeze dims -&gt; ZYX\n    return torch.squeeze(torch.squeeze(result, dim=0), dim=0).numpy()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to skeletonize. This should be a normalized distance field image.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(model)","title":"<code>model</code>","text":"(<code>Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for prediction. This can either be an instance of MultiscaleSkeletonizationNet or the string \"pretrained\". If \"pretrained\", a pretrained model will be downloaded from the SkelePlex repository and used. Default value is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>The size of each tile to predict on. The default value is (120, 120, 120).</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The amount of overlap between tiles. Should be between 0 and 1. Default value is 0.5.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The method to use to stitch overlapping tiles. Should be \"gaussian\" or \"constant\". \"gaussian\" uses a Gaussian kernel to weight the overlapping regions. \"constant\" uses equal weight across overlapping regions. \"gaussian\" is the default.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(progress_bar)","title":"<code>progress_bar</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Displays a progress bar during the prediction when set to True. Default is True.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of tiles to predict at once. Default value is 1.</p>"},{"location":"reference/skeleplex/skeleton/_segment/","title":"_segment","text":""},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment","title":"skeleplex.skeleton._segment","text":"<p>Functions:</p> <ul> <li> <code>segment</code>             \u2013              <p>Segment the structures to be skeletonized.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment","title":"segment","text":"<pre><code>segment(image: ndarray, model: Literal['pretrained'] | MultiscaleSemanticSegmentationNet = 'pretrained', roi_size: tuple[int, int, int] = (120, 120, 120), overlap: float = 0.5, stitching_mode: str = 'gaussian', progress_bar: bool = True, batch_size: int = 1) -&gt; ndarray\n</code></pre> <p>Segment the structures to be skeletonized.</p> <p>In the case of lungs, this would be used to segment the airways.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_segment.py</code> <pre><code>def segment(\n    image: np.ndarray,\n    model: Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    progress_bar: bool = True,\n    batch_size: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"Segment the structures to be skeletonized.\n\n    In the case of lungs, this would be used to segment the airways.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The input image to skeletonize.\n        This should be a normalized distance field image.\n    model : Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",\n        The model to use for prediction. This can either be an instance of\n        MultiscaleSemanticSegmentationNet or the string \"pretrained\". If \"pretrained\",\n        a pretrained model will be downloaded from the SkelePlex repository and used.\n        Default value is \"pretrained\".\n    roi_size : tuple[int, int, int]\n        The size of each tile to predict on.\n        The default value is (120, 120, 120).\n    overlap : float\n        The amount of overlap between tiles.\n        Should be between 0 and 1.\n        Default value is 0.5.\n    stitching_mode : str\n        The method to use to stitch overlapping tiles.\n        Should be \"gaussian\" or \"constant\".\n        \"gaussian\" uses a Gaussian kernel to weight the overlapping regions.\n        \"constant\" uses equal weight across overlapping regions.\n        \"gaussian\" is the default.\n    progress_bar : bool\n        Displays a progress bar during the prediction when set to True.\n        Default is True.\n    batch_size : int\n        The number of tiles to predict at once.\n        Default value is 1.\n    \"\"\"\n    # add dim -&gt; NCZYX\n    expanded_image = torch.from_numpy(make_image_5d(image))\n\n    # get the skeletonziation model if requested\n    if model == \"pretrained\":\n        raise NotImplementedError(\"pretrained segmentation models not implemented.\")\n\n    # put the model in eval mode\n    model.eval()\n\n    # make the prediction\n    with torch.no_grad():\n        result = sliding_window_inference(\n            inputs=expanded_image,\n            sw_batch_size=batch_size,\n            sw_device=torch.device(\"cuda\"),\n            predictor=model,\n            roi_size=roi_size,\n            overlap=overlap,\n            mode=stitching_mode,\n            device=torch.device(\"cpu\"),\n            progress=progress_bar,\n        )\n\n    # squeeze dims -&gt; ZYX\n    return torch.squeeze(torch.squeeze(result, dim=0), dim=0).numpy()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to skeletonize. This should be a normalized distance field image.</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(model)","title":"<code>model</code>","text":"(<code>Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for prediction. This can either be an instance of MultiscaleSemanticSegmentationNet or the string \"pretrained\". If \"pretrained\", a pretrained model will be downloaded from the SkelePlex repository and used. Default value is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>The size of each tile to predict on. The default value is (120, 120, 120).</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The amount of overlap between tiles. Should be between 0 and 1. Default value is 0.5.</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The method to use to stitch overlapping tiles. Should be \"gaussian\" or \"constant\". \"gaussian\" uses a Gaussian kernel to weight the overlapping regions. \"constant\" uses equal weight across overlapping regions. \"gaussian\" is the default.</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(progress_bar)","title":"<code>progress_bar</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Displays a progress bar during the prediction when set to True. Default is True.</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of tiles to predict at once. Default value is 1.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/","title":"_skeletonize","text":""},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize","title":"skeleplex.skeleton._skeletonize","text":"<p>Functions:</p> <ul> <li> <code>skeletonize</code>             \u2013              <p>Skeletonize a normalized distance field image.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize","title":"skeletonize","text":"<pre><code>skeletonize(image: ndarray, model: Literal['pretrained'] | MultiscaleSkeletonizationNet = 'pretrained', roi_size: tuple[int, int, int] = (120, 120, 120), overlap: float = 0.5, stitching_mode: str = 'gaussian', progress_bar: bool = True, batch_size: int = 1) -&gt; ndarray\n</code></pre> <p>Skeletonize a normalized distance field image.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_skeletonize.py</code> <pre><code>def skeletonize(\n    image: np.ndarray,\n    model: Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    progress_bar: bool = True,\n    batch_size: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"Skeletonize a normalized distance field image.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The input image to skeletonize.\n        This should be a normalized distance field image.\n    model : Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",\n        The model to use for prediction. This can either be an instance of\n        MultiscaleSkeletonizationNet or the string \"pretrained\". If \"pretrained\",\n        a pretrained model will be downloaded from the SkelePlex repository and used.\n        Default value is \"pretrained\".\n    roi_size : tuple[int, int, int]\n        The size of each tile to predict on.\n        The default value is (120, 120, 120).\n    overlap : float\n        The amount of overlap between tiles.\n        Should be between 0 and 1.\n        Default value is 0.5.\n    stitching_mode : str\n        The method to use to stitch overlapping tiles.\n        Should be \"gaussian\" or \"constant\".\n        \"gaussian\" uses a Gaussian kernel to weight the overlapping regions.\n        \"constant\" uses equal weight across overlapping regions.\n        \"gaussian\" is the default.\n    progress_bar : bool\n        Displays a progress bar during the prediction when set to True.\n        Default is True.\n    batch_size : int\n        The number of tiles to predict at once.\n        Default value is 1.\n    \"\"\"\n    # add dim -&gt; NCZYX\n    expanded_image = torch.from_numpy(make_image_5d(image))\n\n    # get the skeletonziation model if requested\n    if model == \"pretrained\":\n        model = get_skeletonization_model()\n\n    # put the model in eval mode\n    model.eval()\n\n    # make the prediction\n    with torch.no_grad():\n        result = sliding_window_inference(\n            inputs=expanded_image,\n            sw_batch_size=batch_size,\n            sw_device=torch.device(\"cuda\"),\n            predictor=model,\n            roi_size=roi_size,\n            overlap=overlap,\n            mode=stitching_mode,\n            device=torch.device(\"cpu\"),\n            progress=progress_bar,\n        )\n\n    # squeeze dims -&gt; ZYX\n    return torch.squeeze(torch.squeeze(result, dim=0), dim=0).numpy()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to skeletonize. This should be a normalized distance field image.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(model)","title":"<code>model</code>","text":"(<code>Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for prediction. This can either be an instance of MultiscaleSkeletonizationNet or the string \"pretrained\". If \"pretrained\", a pretrained model will be downloaded from the SkelePlex repository and used. Default value is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>The size of each tile to predict on. The default value is (120, 120, 120).</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The amount of overlap between tiles. Should be between 0 and 1. Default value is 0.5.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The method to use to stitch overlapping tiles. Should be \"gaussian\" or \"constant\". \"gaussian\" uses a Gaussian kernel to weight the overlapping regions. \"constant\" uses equal weight across overlapping regions. \"gaussian\" is the default.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(progress_bar)","title":"<code>progress_bar</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Displays a progress bar during the prediction when set to True. Default is True.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of tiles to predict at once. Default value is 1.</p>"},{"location":"reference/skeleplex/skeleton/_utils/","title":"_utils","text":""},{"location":"reference/skeleplex/skeleton/_utils/#skeleplex.skeleton._utils","title":"skeleplex.skeleton._utils","text":"<p>Utilities for the skeletonization process.</p> <p>Functions:</p> <ul> <li> <code>get_skeletonization_model</code>             \u2013              <p>Get a pretrained model from the SkelePlex repository.</p> </li> <li> <code>make_image_5d</code>             \u2013              <p>Make a 5D image from a 3D, 4D, or 5D image.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_utils/#skeleplex.skeleton._utils.get_skeletonization_model","title":"get_skeletonization_model","text":"<pre><code>get_skeletonization_model() -&gt; MultiscaleSkeletonizationNet\n</code></pre> <p>Get a pretrained model from the SkelePlex repository.</p> <p>Returns:</p> <ul> <li> <code>MultiscaleSkeletonizationNet</code>           \u2013            <p>The pretrained skeletonization model.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_utils.py</code> <pre><code>def get_skeletonization_model() -&gt; MultiscaleSkeletonizationNet:\n    \"\"\"Get a pretrained model from the SkelePlex repository.\n\n    Returns\n    -------\n    MultiscaleSkeletonizationNet\n        The pretrained skeletonization model.\n    \"\"\"\n    # download the weights\n    file_path = SKELETONIZATION_MODEL_REGISTRY.fetch(\"skel-best.ckpt\")\n\n    return MultiscaleSkeletonizationNet.load_from_checkpoint(file_path)\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_utils/#skeleplex.skeleton._utils.make_image_5d","title":"make_image_5d","text":"<pre><code>make_image_5d(image: ndarray) -&gt; ndarray\n</code></pre> <p>Make a 5D image from a 3D, 4D, or 5D image.</p> Source code in <code>skeleplex/skeleton/_utils.py</code> <pre><code>def make_image_5d(image: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Make a 5D image from a 3D, 4D, or 5D image.\"\"\"\n    if image.ndim == 5:\n        return image\n    elif image.ndim == 4:\n        return np.expand_dims(image, axis=0)\n    elif image.ndim == 3:\n        return np.expand_dims(np.expand_dims(image, axis=0), axis=0)\n    else:\n        raise ValueError(\"Image must be 3D, 4D or 5D\")\n</code></pre>"},{"location":"reference/skeleplex/utils/","title":"utils","text":""},{"location":"reference/skeleplex/utils/#skeleplex.utils","title":"skeleplex.utils","text":"<p>Utilities for operating on the skeleton.</p> <p>Functions:</p> <ul> <li> <code>line_segments_in_aabb</code>             \u2013              <p>Get a boolean mask for line segments completely within an AABB.</p> </li> <li> <code>points_in_aabb</code>             \u2013              <p>Create a boolean mask for coordinates within an axis-aligned bounding box.</p> </li> </ul>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.line_segments_in_aabb","title":"line_segments_in_aabb","text":"<pre><code>line_segments_in_aabb(line_segments: ndarray, min_bounds: ndarray, max_bounds: ndarray) -&gt; ndarray\n</code></pre> <p>Get a boolean mask for line segments completely within an AABB.</p> <p>A line segment is considered completely inside the bounding box if both its start and end points are within the bounding box (inclusive of boundaries).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array with shape (n_line_segments,) where True indicates line segments completely within the bounding box.</p> </li> </ul> Source code in <code>skeleplex/utils/_geometry.py</code> <pre><code>def line_segments_in_aabb(\n    line_segments: np.ndarray,\n    min_bounds: np.ndarray,\n    max_bounds: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Get a boolean mask for line segments completely within an AABB.\n\n    A line segment is considered completely inside the bounding box if both\n    its start and end points are within the bounding box (inclusive of boundaries).\n\n    Parameters\n    ----------\n    line_segments : np.ndarray\n        (2 * n_line_segments, n_dim) array of line segment coordinates.\n        Line segment n goes from line_segments[2*n] to line_segments[2*n + 1].\n    min_bounds : np.ndarray\n        (n_dim,) array of the minimum bounds of the bounding box.\n    max_bounds : np.ndarray\n        (n_dim,) array of the maximum bounds of the bounding box.\n\n    Returns\n    -------\n    mask : np.ndarray\n        Boolean array with shape (n_line_segments,) where True indicates\n        line segments completely within the bounding box.\n    \"\"\"\n    # Check that min_bounds &lt;= max_bounds for each dimension\n    if np.any(min_bounds &gt; max_bounds):\n        raise ValueError(\"min_bounds must be &lt;= max_bounds for all dimensions\")\n\n    # Calculate number of line segments\n    n_line_segments = line_segments.shape[0] // 2\n\n    # Reshape to separate start and end points: (n_line_segments, 2, 3)\n    segments_reshaped = line_segments.reshape(n_line_segments, 2, 3)\n\n    # Check if each point is within bounds\n    # Broadcasting: (n_line_segments, 2, 3) &gt;= (3,) -&gt; (n_line_segments, 2, 3)\n    within_min = np.all(segments_reshaped &gt;= min_bounds, axis=2)  # (n_line_segments, 2)\n    within_max = np.all(segments_reshaped &lt;= max_bounds, axis=2)  # (n_line_segments, 2)\n\n    # Both start and end points must be within bounds\n    points_in_bounds = within_min &amp; within_max  # (n_line_segments, 2)\n\n    # Line segment is completely inside if both points are inside\n    segments_completely_inside = np.all(points_in_bounds, axis=1)  # (n_line_segments,)\n\n    expanded_mask = np.repeat(segments_completely_inside, 2)  # (2 * n_line_segments,)\n\n    return expanded_mask\n</code></pre>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.line_segments_in_aabb(line_segments)","title":"<code>line_segments</code>","text":"(<code>ndarray</code>)           \u2013            <p>(2 * n_line_segments, n_dim) array of line segment coordinates. Line segment n goes from line_segments[2n] to line_segments[2n + 1].</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.line_segments_in_aabb(min_bounds)","title":"<code>min_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array of the minimum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.line_segments_in_aabb(max_bounds)","title":"<code>max_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array of the maximum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.points_in_aabb","title":"points_in_aabb","text":"<pre><code>points_in_aabb(coordinates: ndarray, min_bounds: ndarray, max_bounds: ndarray) -&gt; ndarray\n</code></pre> <p>Create a boolean mask for coordinates within an axis-aligned bounding box.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array with shape (n_coordinates,) where True indicates coordinates within the bounding box (inclusive of boundaries).</p> </li> </ul> Source code in <code>skeleplex/utils/_geometry.py</code> <pre><code>def points_in_aabb(\n    coordinates: np.ndarray,\n    min_bounds: np.ndarray,\n    max_bounds: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Create a boolean mask for coordinates within an axis-aligned bounding box.\n\n    Parameters\n    ----------\n    coordinates : np.ndarray\n        (n_coordinates, n_dim) array of point coordinates.\n    min_bounds : np.ndarray\n        (n_dim,) array with the minimum bounds of the bounding box.\n    max_bounds : np.ndarray\n        (n_dim,) array with the maximum bounds of the bounding box.\n\n    Returns\n    -------\n    mask : np.ndarray\n        Boolean array with shape (n_coordinates,) where True indicates\n        coordinates within the bounding box (inclusive of boundaries).\n\n    \"\"\"\n    # Check that min_bounds &lt;= max_bounds for each dimension\n    if np.any(min_bounds &gt; max_bounds):\n        raise ValueError(\"min_bounds must be &lt;= max_bounds for all dimensions\")\n\n    # Vectorized comparison: coordinates &gt;= min_bounds and coordinates &lt;= max_bounds\n    # Broadcasting handles the comparison across all coordinates simultaneously\n    within_min = np.all(coordinates &gt;= min_bounds, axis=1)\n    within_max = np.all(coordinates &lt;= max_bounds, axis=1)\n\n    # Return mask where both conditions are satisfied\n    return within_min &amp; within_max\n</code></pre>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.points_in_aabb(coordinates)","title":"<code>coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_coordinates, n_dim) array of point coordinates.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.points_in_aabb(min_bounds)","title":"<code>min_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array with the minimum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.points_in_aabb(max_bounds)","title":"<code>max_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array with the maximum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/_geometry/","title":"_geometry","text":""},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry","title":"skeleplex.utils._geometry","text":"<p>Functions:</p> <ul> <li> <code>line_segments_in_aabb</code>             \u2013              <p>Get a boolean mask for line segments completely within an AABB.</p> </li> <li> <code>points_in_aabb</code>             \u2013              <p>Create a boolean mask for coordinates within an axis-aligned bounding box.</p> </li> </ul>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.line_segments_in_aabb","title":"line_segments_in_aabb","text":"<pre><code>line_segments_in_aabb(line_segments: ndarray, min_bounds: ndarray, max_bounds: ndarray) -&gt; ndarray\n</code></pre> <p>Get a boolean mask for line segments completely within an AABB.</p> <p>A line segment is considered completely inside the bounding box if both its start and end points are within the bounding box (inclusive of boundaries).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array with shape (n_line_segments,) where True indicates line segments completely within the bounding box.</p> </li> </ul> Source code in <code>skeleplex/utils/_geometry.py</code> <pre><code>def line_segments_in_aabb(\n    line_segments: np.ndarray,\n    min_bounds: np.ndarray,\n    max_bounds: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Get a boolean mask for line segments completely within an AABB.\n\n    A line segment is considered completely inside the bounding box if both\n    its start and end points are within the bounding box (inclusive of boundaries).\n\n    Parameters\n    ----------\n    line_segments : np.ndarray\n        (2 * n_line_segments, n_dim) array of line segment coordinates.\n        Line segment n goes from line_segments[2*n] to line_segments[2*n + 1].\n    min_bounds : np.ndarray\n        (n_dim,) array of the minimum bounds of the bounding box.\n    max_bounds : np.ndarray\n        (n_dim,) array of the maximum bounds of the bounding box.\n\n    Returns\n    -------\n    mask : np.ndarray\n        Boolean array with shape (n_line_segments,) where True indicates\n        line segments completely within the bounding box.\n    \"\"\"\n    # Check that min_bounds &lt;= max_bounds for each dimension\n    if np.any(min_bounds &gt; max_bounds):\n        raise ValueError(\"min_bounds must be &lt;= max_bounds for all dimensions\")\n\n    # Calculate number of line segments\n    n_line_segments = line_segments.shape[0] // 2\n\n    # Reshape to separate start and end points: (n_line_segments, 2, 3)\n    segments_reshaped = line_segments.reshape(n_line_segments, 2, 3)\n\n    # Check if each point is within bounds\n    # Broadcasting: (n_line_segments, 2, 3) &gt;= (3,) -&gt; (n_line_segments, 2, 3)\n    within_min = np.all(segments_reshaped &gt;= min_bounds, axis=2)  # (n_line_segments, 2)\n    within_max = np.all(segments_reshaped &lt;= max_bounds, axis=2)  # (n_line_segments, 2)\n\n    # Both start and end points must be within bounds\n    points_in_bounds = within_min &amp; within_max  # (n_line_segments, 2)\n\n    # Line segment is completely inside if both points are inside\n    segments_completely_inside = np.all(points_in_bounds, axis=1)  # (n_line_segments,)\n\n    expanded_mask = np.repeat(segments_completely_inside, 2)  # (2 * n_line_segments,)\n\n    return expanded_mask\n</code></pre>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.line_segments_in_aabb(line_segments)","title":"<code>line_segments</code>","text":"(<code>ndarray</code>)           \u2013            <p>(2 * n_line_segments, n_dim) array of line segment coordinates. Line segment n goes from line_segments[2n] to line_segments[2n + 1].</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.line_segments_in_aabb(min_bounds)","title":"<code>min_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array of the minimum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.line_segments_in_aabb(max_bounds)","title":"<code>max_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array of the maximum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.points_in_aabb","title":"points_in_aabb","text":"<pre><code>points_in_aabb(coordinates: ndarray, min_bounds: ndarray, max_bounds: ndarray) -&gt; ndarray\n</code></pre> <p>Create a boolean mask for coordinates within an axis-aligned bounding box.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array with shape (n_coordinates,) where True indicates coordinates within the bounding box (inclusive of boundaries).</p> </li> </ul> Source code in <code>skeleplex/utils/_geometry.py</code> <pre><code>def points_in_aabb(\n    coordinates: np.ndarray,\n    min_bounds: np.ndarray,\n    max_bounds: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Create a boolean mask for coordinates within an axis-aligned bounding box.\n\n    Parameters\n    ----------\n    coordinates : np.ndarray\n        (n_coordinates, n_dim) array of point coordinates.\n    min_bounds : np.ndarray\n        (n_dim,) array with the minimum bounds of the bounding box.\n    max_bounds : np.ndarray\n        (n_dim,) array with the maximum bounds of the bounding box.\n\n    Returns\n    -------\n    mask : np.ndarray\n        Boolean array with shape (n_coordinates,) where True indicates\n        coordinates within the bounding box (inclusive of boundaries).\n\n    \"\"\"\n    # Check that min_bounds &lt;= max_bounds for each dimension\n    if np.any(min_bounds &gt; max_bounds):\n        raise ValueError(\"min_bounds must be &lt;= max_bounds for all dimensions\")\n\n    # Vectorized comparison: coordinates &gt;= min_bounds and coordinates &lt;= max_bounds\n    # Broadcasting handles the comparison across all coordinates simultaneously\n    within_min = np.all(coordinates &gt;= min_bounds, axis=1)\n    within_max = np.all(coordinates &lt;= max_bounds, axis=1)\n\n    # Return mask where both conditions are satisfied\n    return within_min &amp; within_max\n</code></pre>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.points_in_aabb(coordinates)","title":"<code>coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_coordinates, n_dim) array of point coordinates.</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.points_in_aabb(min_bounds)","title":"<code>min_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array with the minimum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.points_in_aabb(max_bounds)","title":"<code>max_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array with the maximum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/visualize/","title":"visualize","text":""},{"location":"reference/skeleplex/visualize/#skeleplex.visualize","title":"skeleplex.visualize","text":"<p>Module for interactive visualization and curation of the skeleton.</p> <p>Modules:</p> <ul> <li> <code>spline</code>           \u2013            <p>Utilities for visualizing splines.</p> </li> </ul>"},{"location":"reference/skeleplex/visualize/spline/","title":"spline","text":""},{"location":"reference/skeleplex/visualize/spline/#skeleplex.visualize.spline","title":"skeleplex.visualize.spline","text":"<p>Utilities for visualizing splines.</p> <p>Functions:</p> <ul> <li> <code>line_segment_coordinates_from_spline</code>             \u2013              <p>Get the coordinates for a line segment from a spline.</p> </li> </ul>"},{"location":"reference/skeleplex/visualize/spline/#skeleplex.visualize.spline.line_segment_coordinates_from_spline","title":"line_segment_coordinates_from_spline","text":"<pre><code>line_segment_coordinates_from_spline(spline: B3Spline, n_line_segments: int = 3) -&gt; ndarray\n</code></pre> <p>Get the coordinates for a line segment from a spline.</p> Source code in <code>skeleplex/visualize/spline.py</code> <pre><code>def line_segment_coordinates_from_spline(\n    spline: B3Spline,\n    n_line_segments: int = 3,\n) -&gt; np.ndarray:\n    \"\"\"Get the coordinates for a line segment from a spline.\"\"\"\n    n_knots = len(spline.model.knots)\n    t = np.linspace(0, n_knots - 1, n_line_segments + 1, endpoint=True)\n\n    spline_coordinates = spline.model.eval(t)\n\n    line_coordinates = np.empty((2 * n_line_segments, 3))\n    line_coordinates[::2] = spline_coordinates[:-1]\n    line_coordinates[1::2] = spline_coordinates[1:]\n\n    return line_coordinates\n</code></pre>"}]}